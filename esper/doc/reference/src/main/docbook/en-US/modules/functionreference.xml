<chapter xml:id="functionreference" version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="./" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">

    <title>EPL Reference: Functions</title>
        
	<sect1 xml:id="epl-single-row-function-ref">
		<title>Single-Row Function Reference</title>
		
		<para>
			Single-row functions return a single value for every single result row generated by your statement. These functions can appear anywhere where expressions are allowed.
		</para>

		<indexterm><primary>user-defined single-row function</primary></indexterm>
		<indexterm><primary>functions</primary><secondary>user-defined</secondary></indexterm>
		<indexterm><primary>static Java methods</primary></indexterm>
		<para>
			Esper allows static Java library methods as single-row functions, and also features built-in single-row functions. In addition, Esper allows instance method invocations on named streams.
		</para>
			
		<para>
			You may also register your own single-row function name with the engine so that your EPL statements become less cluttered. This is described in detail in <xref linkend="custom-singlerow-function"/>. Single-row functions that return an object can be chained.
		</para>

		<para>
			Esper auto-imports the following Java library packages:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					java.lang.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.math.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.text.*
				</para>
			</listitem>
			<listitem>
				<para>
					java.util.*
				</para>
			</listitem>
		</itemizedlist>

		<para>
			Thus Java static library methods can be used in all expressions as shown in below example:
		</para>

		<programlisting>select symbol, Math.round(volume/1000)
from StockTickEvent#time(30 sec)</programlisting>
			
		<para>
			In general, arbitrary Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism 
for user-controlled imports of classes and packages as outlined in <xref linkend="config-class--package-imports"/>.
		</para>

		<para>
			The below table outlines the built-in single-row functions available.
		</para>

		<table frame="topbot" xml:id="epl-single-row-func" revision="2">
			<title>Syntax and Results of Single-Row Functions</title>
			<tgroup cols="2">
				<colspec colwidth="2.0*"/>
				<colspec colwidth="1.5*"/>
				<thead>
					<row>
						<entry>Single-row Function</entry>
						<entry>Result</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><synopsis>case <emphasis>value</emphasis> 
  when <emphasis>compare_value</emphasis> then <emphasis>result</emphasis>
  [when <emphasis>compare_value</emphasis> then <emphasis>result</emphasis> ...] 
  [else <emphasis>result</emphasis>] 
  end </synopsis></entry>
						<entry>
							<para>
								Returns <literal>result</literal> where the first <literal>value</literal> equals <literal>compare_value</literal>. 
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>case 
  when <emphasis>condition</emphasis> then <emphasis>result</emphasis>
  [when <emphasis>condition</emphasis> then <emphasis>result</emphasis> ...] 
  [else <emphasis>result</emphasis>] 
  end</synopsis></entry>
						<entry>
							<para>
								Returns the <literal>result</literal> for the first condition that is true.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>cast(<emphasis>expression</emphasis>, <emphasis>type_name</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Casts the result of an expression to the given type. 
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>coalesce(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the first non-<literal>null</literal> value in the list, or <literal>null</literal> if there are no non-<literal>null</literal> values.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>current_evaluation_context()</synopsis></entry>
						<entry>
							<para>
								Returns an object containing the engine URI, EPL statement name and context partition id (when applicable).
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>current_timestamp[()]</synopsis></entry>
						<entry>
							<para>
								Returns the current engine time as a <literal>long</literal> value. Reserved keyword with optional parenthesis.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>exists(<emphasis>dynamic_property_name</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Returns true if the dynamic property exists for the event, or false if the property does not exist.
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>instanceof(<emphasis>expression</emphasis>, <emphasis>type_name</emphasis> [, <emphasis>type_name</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns true if the expression returns an object whose type is one of the types listed.
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>istream()</synopsis></entry>
						<entry>
							<para>
								Returns true if the event is part of the insert stream and false if the event is part of the remove stream.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>max(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the highest numeric value among the 2 or more comma-separated expressions.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>min(<emphasis>expression</emphasis>, <emphasis>expression</emphasis> [, <emphasis>expression</emphasis> ...])</synopsis></entry>
						<entry>
							<para>
								Returns the lowest numeric value among the 2 or more comma-separated expressions.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prev(<emphasis>expression</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value or all properties of a previous event, relative to the event order within a data window, or according to an optional index parameter (N) the positional Nth-from-last value.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prevtail(<emphasis>expression</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value or all properties of the first event in a data window relative to the event order within a data window, or according to an optional index parameter (N) the positional Nth-from-first value.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prevwindow(<emphasis>event_property</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Returns a single property value of all events or all properties of all events in a data window in the order that reflects the sort order of the data window.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prevcount(<emphasis>event_property</emphasis>)</synopsis></entry>
						<entry>
							<para>
								Returns the count of events (number of data points) in a data window.
							</para>
						</entry>
					</row>
					<row>
						<entry><synopsis>prior(<emphasis>expression</emphasis>, <emphasis>event_property)</emphasis></synopsis></entry>
						<entry>
							<para>
								Returns a property value of a prior event, relative to the natural order of arrival of events
							</para>
						</entry>
					</row>
					<row>
					  <entry><synopsis>typeof(<emphasis>expression</emphasis>)</synopsis></entry>
						<entry>
							<para>
								If expression is a stream name, returns the event type name of the evaluated event, often used with variant streams. 
								If expression is a property name or expression, returns the name of the expression result type.
							</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

		<sect2 xml:id="epl-single-row-function-ref-case">
			<title>The <literal>Case</literal> Control Flow Function</title>

			<indexterm><primary>case control flow function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>case control flow</secondary></indexterm>
			<para>
				The <literal>case</literal> control flow function has two versions. The first version takes a value and a list of compare values to compare against, and returns the result where the first value equals the compare value. The second version takes a list of conditions and returns the result for the first condition that is true.
			</para>

			<para>
				The return type of a <literal>case</literal> expression is the compatible aggregated type of all return values.
			</para>
			
			<para>
				The <literal>case</literal> expression is sometimes used with the <literal>new</literal> operator to return multiple results, see <xref linkend="epl-operator-new"/>.
			</para>

			<para>
				The example below shows the first version of a <literal>case</literal> statement. It has a <literal>String</literal> return type and returns the value 'one'.
			</para>
			<programlisting>select case myexpression when 1 then 'one' when 2 then 'two' else 'more' end from ...</programlisting>
				
			<para>
				The second version of the <literal>case</literal> function takes a list of conditions. The next example has a <literal>Boolean</literal> return type and returns the boolean value true.
			</para>				
			<programlisting>select case when 1>0 then true else false end from ...</programlisting>
		</sect2>
		

		<sect2 xml:id="epl-single-row-function-cast">
			<title>The <literal>Cast</literal> Function</title>

			<indexterm><primary>cast function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>cast</secondary></indexterm>
			<para>
				The <literal>cast</literal> function casts the return type of an expression to a designated type. The function accepts two parameters: 
				The first parameter is the property name or expression that returns the value to be casted. The second parameter is the type to cast to.
				You can use the <literal>as</literal> keyword instead of comma (<literal>,</literal>) to separate parameters.
			</para>

			<para>
				Valid parameters for the second (type) parameter are:
			</para>
	
			<itemizedlist>
				<listitem>
					<para>
						Any of the Java built-in types: <literal>int, long, byte, short, char, double, float, string, BigInteger, BigDecimal</literal>, where <literal>string</literal>  is a short notation for <literal>java.lang.String</literal> and <literal>BigInteger</literal> as well as <literal>BigDecimal</literal> are the classes in <literal>java.math</literal>. The type name is not case-sensitive. For example:
						<synopsis>cast(price, double)</synopsis>
					</para>
				</listitem>
				<listitem>
					<para>
						The fully-qualified class name of the class to cast to, for example: <synopsis>cast(product as org.myproducer.Product)</synopsis>
					</para>
				</listitem>
				<listitem>
					<para>
						For parsing date-time values, any of the date-time types: <literal>date, calendar, long, localdatetime, zoneddatetime, localdate, localtime</literal>. For these types the <literal>dateformat</literal> parameter is required as discussed below.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				The <literal>cast</literal> function is often used to provide a type for dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. 
				These properties are always of type <literal>java.lang.Object</literal>. 
			</para>
			
			<para>
				The <literal>cast</literal> function as shown in the next statement casts the dynamic "price" property of an "item" in the OrderEvent to a double value.
			</para>
			<programlisting><![CDATA[select cast(item.price?, double) from OrderEvent]]></programlisting>

			<para>
				The <literal>cast</literal> function returns a <literal>null</literal> value if the expression result cannot be casted to the desired type, or if the expression result itself is <literal>null</literal>.
			</para>

			<para>
				The <literal>cast</literal> function adheres to the following type conversion rules:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						For all numeric types, the <literal>cast</literal> function utilitzes <literal>java.lang.Number</literal> to convert numeric types, if required. 
					</para>
				</listitem>
				<listitem>
					<para>
						For casts to <literal>string</literal> or <literal>java.lang.String</literal>, the function calls <literal>toString</literal> on the expression result.
					</para>
				</listitem>
				<listitem>
					<para>
						For casts to other objects including application objects, the <literal>cast</literal> function considers a Java class's superclasses as well as all directly or indirectly-implemented interfaces by superclasses.
					</para>
				</listitem>
			</itemizedlist>

			<sect3 xml:id="epl-single-row-function-cast-parsedate">
				<title>The <literal>Cast</literal> Function For Parsing Dates</title>
	
				<indexterm><primary>cast function</primary><secondary>date parsing</secondary></indexterm>
				<para>
					The <literal>cast</literal> function can parse string-type date-time values to long-type milliseconds, <literal>Date</literal>, <literal>Calendar</literal>, <literal>LocalDateTime</literal>, <literal>ZonedDateTime</literal>, <literal>LocalDate</literal> and <literal>LocalTime</literal> objects.
				</para>

				<para>
					You must provide the <literal>dateformat</literal> named parameter as the last parameter to the <literal>cast</literal> function. 
					The <literal>dateformat</literal> parameter expression must return a <literal>String</literal>-typed value, a <literal>SimpleDateFormat</literal>-type value or a <literal>DateTimeFormatter</literal>-type value. 
					Return a <literal>SimpleDateFormat</literal> for <literal>long</literal>/<literal>Date</literal>/<literal>Calendar</literal>.
					Return a <literal>DateTimeFormatter</literal> for <literal>LocalDateTime</literal>/<literal>ZonedDateTime</literal>/<literal>LocalDate</literal>/<literal>LocalTime</literal>.
				</para>
								
				<para>
					The next EPL outputs the date May 2, 2010 as a <literal>Date</literal>-type value:
				</para>
				<programlisting><![CDATA[select cast('20100502', date, dateformat: 'yyyyMMdd') from OrderEvent]]></programlisting>
				
				<para>
					You may use date-time methods when <literal>cast</literal> is returning a date-time value. Expressions can be any expression and do not need to be string constants.
				</para>
				
				<para>
					You may parse dates that are ISO 8601-formatted dates by specifying <literal>iso</literal> as the date format. The ISO 8601 date format is described in <xref linkend="pattern-timer-schedule-date"/>.
				</para>
				<para>
					For example, assuming the <literal>orderDate</literal> property is a ISO 8601 formatted date, the engine can convert it to a long millisecond value like this:
				</para>
				<programlisting><![CDATA[select cast(orderDate, long, dateformat: 'iso') from OrderEvent]]></programlisting>
				
				<para>
					The next table shows the recognized date types available:
				</para>

				<table frame="topbot" xml:id="epl-single-row-function-cast-parsedate-types" revision="2">
					<title>Date Types for Casting/Parsing</title>
					<tgroup cols="2">
						<colspec colwidth="2.0*"/>
						<colspec colwidth="1.5*"/>
						<thead>
							<row>
								<entry>Value provided to Cast as the second parameter</entry>
								<entry>Result Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>date</literal>, <literal>java.util.Date</literal></entry>
								<entry><literal>java.util.Date</literal></entry>
							</row>
							<row>
								<entry><literal>calendar</literal>, <literal>java.util.Calendar</literal></entry>
								<entry><literal>java.util.Calendar</literal></entry>
							</row>
							<row>
								<entry><literal>long</literal>, <literal>java.lang.Long</literal></entry>
								<entry><literal>long</literal></entry>
							</row>
							<row>
								<entry><literal>localdatetime</literal>, <literal>java.time.LocalDateTime</literal></entry>
								<entry><literal>java.time.LocalDateTime</literal></entry>
							</row>
							<row>
								<entry><literal>localdate</literal>, <literal>java.time.LocalDate</literal></entry>
								<entry><literal>java.time.LocalDate</literal></entry>
							</row>
							<row>
								<entry><literal>localtime</literal>, <literal>java.time.LocalTime</literal></entry>
								<entry><literal>java.time.LocalTime</literal></entry>
							</row>
							<row>
								<entry><literal>zoneddatetime</literal>, <literal>java.time.ZonedDateTime</literal></entry>
								<entry><literal>java.time.ZonedDateTime</literal></entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</sect3>

			<para>
				Additional examples are:
			</para>
			<programlisting><![CDATA[select cast(orderDate, localdatetime, dateformat:java.time.format.DateTimeFormatter.ISO_DATE_TIME) from OrderEvent]]></programlisting>
			<programlisting><![CDATA[select cast(orderDate, calendar, dateformat:SimpleDateFormat.getInstance()) from OrderEvent]]></programlisting>
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-coalesce">
			<title>The <literal>Coalesce</literal> Function</title>

			<indexterm><primary>coalesce function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>coalesce</secondary></indexterm>
			<para>
				The result of the <literal>coalesce</literal> function is the first expression in a list of expressions that returns a non-null value. The return type is the compatible aggregated type of all return values.
			</para>
			
			<para>
				This example returns a String-typed result of value 'foo':
			</para>
			<programlisting>select coalesce(null, 'foo') from ...</programlisting>			
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-currentevaluationcontext">
			<title>The <literal>Current_Evaluation_Context</literal> Function</title>

			<indexterm><primary>current_evaluation_context</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>current_evaluation_context</secondary></indexterm>
			<para>
				The <literal>current_evaluation_context</literal> function takes no parameters and returns expression evaluation contextual information as an object of type
				<literal>com.espertech.esper.client.hook.EPLExpressionEvaluationContext</literal>. The object provides the engine URI, the statement name and the context partition id of 
				the currently-evaluated expression.
			</para>
			
			<para>
				For example:
			</para>
			<programlisting><![CDATA[select current_evaluation_context().getEngineURI() as engineURI from MyEvent]]></programlisting>
			
			<para>
				The context partition id will be <literal>-1</literal> when the statement is not associated to a context.
			</para>
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-currenttime">
			<title>The <literal>Current_Timestamp</literal> Function</title>

			<indexterm><primary>current_timestamp function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>current_timestamp</secondary></indexterm>
			<para>
				The <literal>current_timestamp</literal> function is a reserved keyword and requires no parameters. The result of the <literal>current_timestamp</literal> function is the <literal>long</literal>-type value of the current engine system time.
			</para>
			
			<para>
				The function returns the current engine timestamp at the time of expression evaluation. When using external-timer events, the function provides the last value of the externally-supplied time at the time of expression evaluation.
			</para>

			<para>
				This example selects the current engine time:
			</para>
			<programlisting><![CDATA[select current_timestamp from MyEvent
// equivalent to
select current_timestamp() from MyEvent]]></programlisting>
		</sect2>

		<sect2 xml:id="epl-single-row-function-exists">
			<title>The <literal>Exists</literal> Function</title>

			<indexterm><primary>exists function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>exists</secondary></indexterm>
			<para>
				The <literal>exists</literal> function returns a boolean value indicating whether the dynamic property, provided as a parameter to the function, exists on the event. The <literal>exists</literal> function accepts a single dynamic property name as its only parameter. 
			</para>

			<para>
				The <literal>exists</literal> function is for use with dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. Dynamic properties return a null value
				if the dynamic property does not exists on an event, or if the dynamic property exists but the value of the dynamic property is null. 
			</para>
			
			<para>
				The <literal>exists</literal> function as shown next returns true if the "item" property contains an object that has a "serviceName" property. It returns false if the "item" property is null, or if the "item" property does not 
				contain an object that has a property named "serviceName" :
			</para>
			<programlisting><![CDATA[select exists(item.serviceName?) from OrderEvent]]></programlisting> 
		</sect2>

		<sect2 xml:id="epl-single-row-function-grouping">
			<title>The <literal>Grouping</literal> Function</title>

			<indexterm><primary>grouping function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>grouping</secondary></indexterm>
			<para>
				The <literal>grouping</literal> function is a SQL-standard function useful in statements that have a <literal>group by</literal>-clause and that utilize one of the <literal>rollup</literal>, <literal>cube</literal> or <literal>grouping sets</literal> keywords. The function can be used only in the <literal>select</literal>-clause, <literal>having</literal>-clause and <literal>order by</literal>-clauses.
			</para>

			<para>
				The function takes a single expression as a parameter and returns an integer value of zero or one indicating whether a specified expression in a <literal>group-by</literal>-clause is aggregated or not. 
				The function returns 1 for aggregated or 0 for not aggregated. 
			</para>
			
			<para>
				The <literal>grouping</literal> function can help you distinguish null values returned because of the output row's aggregation level from null values returned by event properties or other expressions. 
			</para>
			
			<para>
				The parameter expression must match exactly one of the expressions in the <literal>group-by</literal>-clause.
			</para>

			<para>
				Please see an example in the next section.
			</para>			
		</sect2>

		<sect2 xml:id="epl-single-row-function-groupingid">
			<title>The <literal>Grouping_Id</literal> Function</title>

			<indexterm><primary>grouping_id function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>grouping_id</secondary></indexterm>
			<para>
				The <literal>grouping_id</literal> function is a SQL-standard function useful in statements that have a <literal>group by</literal>-clause and that utilize one of the <literal>rollup</literal>, <literal>cube</literal> or <literal>grouping sets</literal> keywords. The function can be used only in the <literal>select</literal>-clause, <literal>having</literal>-clause and <literal>order by</literal>-clauses.
			</para>

			<para>
				The function takes one or more expressions as a parameter and returns an integer value indicating grouping level. The engine computes the grouping level by taking the results of multiple <literal>grouping</literal> functions and concatenating them into a bit vector (a string of ones and zeros).
			</para>
			
			<para>
				Assume a car event that has a property for name, place and number of cars:
			</para>	
			<programlisting>create schema CarEvent(name string, place string, numcars int)</programlisting>

			<para>
				The next EPL computes the total number of cars for each of the following groupings: per name and place, per name, per place and overall.
			</para>	
			<programlisting>select name, place, sum(numcars), grouping(name), grouping(place), grouping_id(name, place)
from CarEvent group by grouping sets((name, place),name, place,())</programlisting>

			<para>
				Assume your application processes a car event with properties like so: <literal>CarEvent={name='skoda', place='france', numcars=100}</literal>.
			</para>	
			
			<para>
				The engine outputs 4 rows as shown in the next table:
			</para>
			<table frame="topbot" xml:id="epl-single-row-function-grouping-out1" revision="2">
				<title>Example Output for <literal>Grouping</literal> and <literal>Grouping_id</literal> Functions (CarEvent 1)</title>
				<tgroup cols="6">
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<thead>
						<row>
							<entry>name</entry>
							<entry>place</entry>
							<entry>sum(numcars)</entry>
							<entry>grouping(name)</entry>
							<entry>grouping(place)</entry>
							<entry>grouping_id(name, place)</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>skoda</entry>
							<entry>france</entry>
							<entry>100</entry>
							<entry>0</entry>
							<entry>0</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>skoda</entry>
							<entry>null</entry>
							<entry>100</entry>
							<entry>0</entry>
							<entry>1</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>null</entry>
							<entry>france</entry>
							<entry>100</entry>
							<entry>1</entry>
							<entry>0</entry>
							<entry>2</entry>
						</row>
						<row>
							<entry>null</entry>
							<entry>null</entry>
							<entry>100</entry>
							<entry>1</entry>
							<entry>1</entry>
							<entry>3</entry>
						</row>
					</tbody>
				</tgroup>
			</table>	

			<para>
				Assume your application processes a second car event: <literal>CarEvent={name='skoda', place='germany', numcars=75}</literal>.
			</para>	
			
			<para>
				The engine outputs 4 rows as shown in the next table:
			</para>
			<table frame="topbot" xml:id="epl-single-row-function-grouping-out2" revision="2">
				<title>Example Output for <literal>Grouping</literal> and <literal>Grouping_id</literal> Functions (CarEvent 2)</title>
				<tgroup cols="6">
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<thead>
						<row>
							<entry>name</entry>
							<entry>place</entry>
							<entry>sum(numcars)</entry>
							<entry>grouping(name)</entry>
							<entry>grouping(place)</entry>
							<entry>grouping_id(name, place)</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>skoda</entry>
							<entry>germany</entry>
							<entry>75</entry>
							<entry>0</entry>
							<entry>0</entry>
							<entry>0</entry>
						</row>
						<row>
							<entry>skoda</entry>
							<entry>null</entry>
							<entry>175</entry>
							<entry>0</entry>
							<entry>1</entry>
							<entry>1</entry>
						</row>
						<row>
							<entry>null</entry>
							<entry>germany</entry>
							<entry>75</entry>
							<entry>1</entry>
							<entry>0</entry>
							<entry>2</entry>
						</row>
						<row>
							<entry>null</entry>
							<entry>null</entry>
							<entry>175</entry>
							<entry>1</entry>
							<entry>1</entry>
							<entry>3</entry>
						</row>
					</tbody>
				</tgroup>
			</table>	

			<para>
				The parameter expressions must match exactly to expressions in the <literal>group-by</literal>-clause.
			</para>
		</sect2>

		<sect2 xml:id="epl-single-row-function-instanceof">
			<title>The <literal>Instance-Of</literal> Function</title>

			<indexterm><primary>instance-of function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>instance-of</secondary></indexterm>
			<para>
				The <literal>instanceof</literal> function returns a boolean value indicating whether the type of value returned by the expression is one of the given types. The first parameter to the <literal>instanceof</literal> function is an expression to evaluate. The second and subsequent parameters are Java type names.
			</para>

			<para>
				The function determines the return type of the expression at runtime by evaluating the expression, and compares the type of object returned by the expression to the defined types. 
				If the type of object returned by the expression matches any of the given types, the function returns <literal>true</literal>. If the expression returned <literal>null</literal> or a type that does not
				match any of the given types, the function returns <literal>false</literal>.
			</para>

			<para>
				The <literal>instanceof</literal> function is often used in conjunction with dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. 
			</para>

			<para>
				This example uses the <literal>instanceof</literal> function to select different properties based on the type:
			</para>
			<programlisting>select case when instanceof(item, com.mycompany.Service) then serviceName?
  when instanceof(item, com.mycompany.Product) then productName? end 
  from OrderEvent</programlisting>

			<para>
				The <literal>instanceof</literal> function returns <literal>false</literal> if the expression tested by instanceof returned null.
			</para>

			<para>
				Valid parameters for the type parameter list are:
			</para>
	
			<itemizedlist>
				<listitem>
					<para>
						Any of the Java built-in types: <literal>int, long, byte, short, char, double, float, string</literal>, where <literal>string</literal>  is a short notation for <literal>java.lang.String</literal>. The type name is not case-sensitive. For example, the next function tests if the dynamic "price" property is either of type float or type double:
						<synopsis>instanceof(price?, double, float)</synopsis>
					</para>
				</listitem>
				<listitem>
					<para>
						The fully-qualified class name of the class to cast to, for example: <synopsis>instanceof(product, org.myproducer.Product)</synopsis>
					</para>
				</listitem>
			</itemizedlist>
			
			<para>
				The function considers an event class's superclasses as well as all the directly or indirectly-implemented interfaces by superclasses.
			</para>
		</sect2>

		<sect2 xml:id="epl-single-row-function-istream">
			<title>The <literal>Istream</literal> Function</title>

			<indexterm><primary>istream</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>istream</secondary></indexterm>
			<para>
				The <literal>istream</literal> function returns a boolean value indicating whether within the context of expression evaluation the current event or set of events (joins) are part of the insert stream (true) or part of the remove stream (false). The function takes no parameters.
			</para>

			<para>
				Use the <literal>istream</literal> function with data windows and <literal>select irstream</literal> and <literal>insert irstream into</literal>. 
			</para>

			<para>
				In the following example the <literal>istream</literal> function always returns boolean true since no data window is declared:
			</para>
			<programlisting>select irstream *, istream() from OrderEvent</programlisting>

			<para>
				The next example declares a data window. For newly arriving events the function returns boolean true, for events that expire after 10 seconds the function returns boolean false:
			</para>
			<programlisting>select irstream *, istream() from OrderEvent#time(10 sec)</programlisting>
			
			<para>
			   The <literal>istream</literal> function returns true for all cases where insert or remove stream does not apply, such as when used in parameter expressions to data windows
			   or in stream filter expressions.
			</para>
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-minmax">
			<title>The <literal>Min</literal> and <literal>Max</literal> Functions</title>

			<indexterm><primary>min function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>min</secondary></indexterm>
			<indexterm><primary>max function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>max</secondary></indexterm>
			<para>
				The <literal>min</literal> and <literal>max</literal> function take two or more parameters that itself can be expressions. The <literal>min</literal> function returns the lowest numeric value among the 2 or more comma-separated expressions, while the <literal>max</literal> function returns the highest numeric value.
				The return type is the compatible aggregated type of all return values.
			</para>

			<para>
				The next example shows the <literal>max</literal> function that has a <literal>Double</literal> return type and returns the value 1.1.
			</para>
			<programlisting>select max(1, 1.1, 2 * 0.5) from ...</programlisting>

			<para>
				The <literal>min</literal> function returns the lowest value. The statement below uses the function to determine the smaller of two timestamp values.
			</para>
	
			<programlisting>select symbol, min(ticks.timestamp, news.timestamp) as minT
	from StockTickEvent#time(30 sec) as ticks, NewsEvent#time(30 sec) as news
	where ticks.symbol = news.symbol</programlisting>
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-previous">
			<title>The <literal>Previous</literal> Function</title>

			<indexterm><primary>previous function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous</secondary></indexterm>
			<para>
				The <literal>prev</literal> function returns the property value or all event properties of a previous event. For data windows that introduce a sort order other than the order of arrival, such as the sorted data window and the time order data window,  the function returns the event at the specified position.
			</para>

			<para>
				The <literal>prev</literal> function is not an aggregation function and therefore does not return results per group when used with <literal>group by</literal>. Please consider the <literal>last</literal>, <literal>lastever</literal> or <literal>first</literal> aggregation functions instead as described in <xref linkend="epl-function-aggregation-event"/>. You must use an aggregation function instead of <literal>prev</literal> when querying a named window or table.
			</para>

			<para>
				The first parameter to the <literal>prev</literal> function is an index parameter and denotes the i-th previous event, in the order established by the data window. If no index is provided, the default index is 1 and the function returns the previous event.
				The second parameter is a property name or stream name. If specifying a property name, the function returns the value for the previous event property value. If specifying a stream name, the function returns the previous event underlying object.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the 2nd-previous event from the current Trade event:
			</para>
			<programlisting>select prev(2, price) from Trade#length(10)</programlisting>

			<para>
				By using the stream alias in the <literal>previous</literal> function, the next example selects the trade event itself that is immediately previous to the current Trade event
			</para>
			<programlisting>select prev(1, trade) from Trade#length(10) as trade</programlisting>

			<para>
				Since the <literal>prev</literal> function takes the order established by the data window into account, the function works well with sorted windows.
			</para>
			<para>
				In the following example the statement selects the symbol of the 3 Trade events that had the largest, second-largest and third-largest volume.
			</para>
			<programlisting>select prev(0, symbol), prev(1, symbol), prev(2, symbol)
  from Trade#sort(3, volume desc)</programlisting>

			<para>
				The i-th previous event parameter can also be an expression returning an Integer-type value. The next statement joins the Trade data window with an <literal>RankSelectionEvent</literal> event that provides a <literal>rank</literal> property used to look up a certain position in the sorted Trade data window:
			</para>
			<programlisting>select prev(rank, symbol) from Trade#sort(10, volume desc), RankSelectionEvent unidirectional</programlisting>

			<para>
				Use the <literal>prev</literal> function in combination with a grouped data window to access a previous event per grouping criteria.
			</para>			
			<para>
				The example below returns the price of the previous Trade event for the same symbol, or <literal>null</literal> if for that symbol there is no previous Trade event:
			</para>
			<programlisting>select prev(1, price) from Trade#groupwin(symbol)#length(2)</programlisting>

			<para>
				The <literal>prev</literal> function returns a <literal>null</literal> value if the data window does not currently hold the i-th previous event. The example below illustrates this using a time batch window. Here the <literal>prev</literal>  
				function returns a null value for any events in which the previous event is not in the same batch of events. Note that the <literal>prior</literal> function as discussed below can be used if a null value is not the desired result.
			</para>
			<programlisting>select prev(1, symbol) from Trade#time_batch(1 min)</programlisting>			

			<para>
				An alternative form of the <literal>prev</literal> function allows the index to not appear or appear after the property name if the index value is a constant and not an expression:
			</para>
			<programlisting>select prev(1, symbol) from Trade
// ... equivalent to ...
select prev(symbol) from Trade
// ... and ...
select prev(symbol, 1) from Trade</programlisting>			

			<para>
				The combination of the <literal>prev</literal> function and <literal>#groupwin</literal> returns the property value for a previous event in the given data window group. 
			</para>

			<para>
				The following example returns for each event the current smallest price per symbol:
			</para>
			<programlisting>select symbol, prev(0, price) as topPricePerSymbol 
from Trade#groupwin(symbol)#sort(1, price asc)</programlisting>
			
			<sect3 xml:id="epl-single-row-function-ref-prev-restrictions">
				<title>Restrictions</title>
				<para>
						The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events.
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window, or <literal>#groupwin</literal> and a data window. See <xref linkend="win-views"/> for data windows.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>

			<sect3 xml:id="epl-single-row-function-ref-prev-prior">
				<title>Comparison to the <literal>Prior</literal> Function</title>
				<para>
					The <literal>prev</literal> function is similar to the <literal>prior</literal> function. The key differences between the two functions are as follows:				 
				</para>						
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The <literal>prev</literal> function returns previous events in the order provided by the data window, while the <literal>prior</literal> function returns prior events in the order of arrival as posted by a stream's declared windows.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function requires a data window while the <literal>prior</literal> function does not have any such requirement.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function returns the previous event grouped by a criteria by combining the <literal>#groupwin</literal> and a data window. The <literal>prior</literal> function returns prior events posted regardless of data window grouping.
						</para>
					</listitem>
					<listitem>
						<para>
							The <literal>prev</literal> function returns a <literal>null</literal> value for remove stream events, i.e. for events leaving a data window. 
							The <literal>prior</literal> function does not have this restriction.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>
			
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-previoustail">
			<title>The <literal>Previous-Tail</literal> Function</title>

			<indexterm><primary>previous tail function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous tail</secondary></indexterm>
			<para>
				The <literal>prevtail</literal> function returns the property value or all event properties of the positional-first event in a data window. For data windows that introduce a sort order other than the order of arrival, such as the sorted data window and the time order data window, the function returns the first event at the specified position.
			</para>

			<para>
				The <literal>prevtail</literal> function is not an aggregation function and therefore does not return results per group when used with <literal>group by</literal>. Please consider the <literal>first</literal>, <literal>firstever</literal> or <literal>window</literal> aggregation functions instead as described in <xref linkend="epl-function-aggregation-event"/>. You must use an aggregation function instead of <literal>prevtail</literal> when querying a named window or table.
			</para>

			<para>
				The first parameter is an index parameter and denotes the i-th from-first event in the order established by the data window. If no index is provided the default is zero and the function returns the first event in the data window.
				The second parameter is a property name or stream name. If specifying a property name, the function returns the value for the previous event property value. If specifying a stream name, the function returns the previous event underlying object.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the first (oldest) event held in the length window:
			</para>
			<programlisting>select prevtail(price) from Trade#length(10)</programlisting>

			<para>
				By using the stream alias in the <literal>prevtail</literal> function, the next example selects the trade event itself that is the second event held in the length window:
			</para>
			<programlisting>select prevtail(1, trade) from Trade#length(10) as trade</programlisting>

			<para>
				Since the <literal>prevtail</literal> function takes the order established by the data window into account, the function works well with sorted windows.
			</para>

			<para>
				In the following example the statement selects the symbol of the 3 Trade events that had the smallest, second-smallest and third-smallest volume.
			</para>
			<programlisting>select prevtail(0, symbol), prevtail(1, symbol), prevtail(2, symbol)
  from Trade#sort(3, volume asc)</programlisting>

			<para>
				The i-th previous event parameter can also be an expression returning an Integer-type value. The next statement joins the Trade data window with an <literal>RankSelectionEvent</literal> event that provides a <literal>rank</literal> property used to look up a certain position in the sorted Trade data window:
			</para>
			<programlisting>select prevtail(rank, symbol) from Trade#sort(10, volume asc), RankSelectionEvent unidirectional</programlisting>

			<para>
				The <literal>prev</literal> function returns a <literal>null</literal> value if the data window does not currently holds positional-first or the Nth-from-first event. For batch data windows the value returned is relative to the current batch.
			</para>

			<para>
				The following example returns the first and second symbol value in the batch:
			</para>
			<programlisting>select prevtail(0, symbol), prevtail(1, symbol) from Trade#time_batch(1 min)</programlisting>			

			<para>
				An alternative form of the <literal>prevtail</literal> function allows the index to not appear or appear after the property name if the index value is a constant and not an expression:
			</para>
			<programlisting>select prevtail(1, symbol) from Trade
// ... equivalent to ...
select prevtail(symbol) from Trade
// ... and ...
select prevtail(symbol, 1) from Trade</programlisting>			

			<para>
				The combination of the <literal>prevtail</literal> function and <literal>#groupwin</literal> returns the property value for a positional first event in the given data window group. 
			</para>

			<para>
				Let's look at an example. This statement outputs the oldest price per symbol retaining the last 10 prices per symbol:
			</para>
			<programlisting>select symbol, prevtail(0, price) as oldestPrice
from Trade#groupwin(symbol)#length(10)</programlisting>
			
			<sect3 xml:id="epl-single-row-function-ref-prevtail-restrictions">
				<title>Restrictions</title>
				<para>
						The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events.
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window, or a <literal>#groupwin</literal> and a data window. See <xref linkend="win-views"/> for built-in data windows.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>			
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-previouswindow">
			<title>The <literal>Previous-Window</literal> Function</title>

			<indexterm><primary>previous window function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous window</secondary></indexterm>
			<para>
				The <literal>prevwindow</literal> function returns property values or all event properties for all events in a data window. For data windows that introduce a sort order other than the order of arrival, such as the sorted data window and the time order data window, the function returns the event data sorted in that order, otherwise it returns the events sorted by order of arrival with the newest arriving event first.
			</para>

			<para>
				The <literal>prevwindow</literal> function is not an aggregation function and therefore does not return results per group when used with <literal>group by</literal>. Please consider the <literal>window</literal> aggregation function instead as described in <xref linkend="epl-function-aggregation-event"/>. You must use an aggregation function instead of <literal>prevwindow</literal> when querying a named window or table.
			</para>

			<para>
				The single parameter is a property name or stream name. If specifying a property name, the function returns the value of the event property for all events held by the data window. If specifying a stream name, the function returns the event underlying object for all events held by the data window.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of all events held in the length window:
			</para>
			<programlisting>select prevwindow(price) from Trade#length(10)</programlisting>

			<para>
				By using the stream alias in the <literal>prevwindow</literal> function, the next example selects all trade events held in the length window:
			</para>
			<programlisting>select prevwindow(trade) from Trade#length(10) as trade</programlisting>

			<para>
				When used with a data window that introduces a certain sort order, the <literal>prevwindow</literal> function returns events sorted according to that sort order.
			</para>
			
			<para>
			  The next statement outputs for every arriving event the current 10 underying trade event objects that have the largest volume:
			</para>
			<programlisting>select prevwindow(trade) from Trade#sort(10, volume desc) as trade</programlisting>

			<para>
				The <literal>prevwindow</literal> function returns a <literal>null</literal> value if the data window does not currently hold any events.
			</para>

			<para>
				The combination of the <literal>prevwindow</literal> function and <literal>#groupwin</literal> returns the property value(s) for all events in the given data window group. 
			</para>

			<para>
				This example statement outputs all prices per symbol retaining the last 10 prices per symbol:
			</para>
			<programlisting>select symbol, prevwindow(price) from Trade#groupwin(symbol)#length(10)</programlisting>
			
			<sect3 xml:id="epl-single-row-function-ref-prevwindow-restrictions">
				<title>Restrictions</title>
				<para>
					The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events.
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window, or <literal>#groupwin</literal> and a data window. See <xref linkend="win-views"/> for built-in data windows.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>			
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-previouscount">
			<title>The <literal>Previous-Count</literal> Function</title>

			<indexterm><primary>previous count function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>previous count</secondary></indexterm>
			<para>
				The <literal>prevcount</literal> function returns the number of events held in a data window.
			</para>

			<para>
				The <literal>prevcount</literal> function is not an aggregation function and therefore does not return results per group when used with <literal>group by</literal>. Please consider the <literal>count(*)</literal> or <literal>countever</literal> aggregation functions instead as described in <xref linkend="epl-function-aggregation"/>. You must use an aggregation function instead of <literal>prevcount</literal> when querying a named window or table.
			</para>

			<para>
				The single parameter is a property name or stream name of the data window to return the count for.
			</para>

			<para>
				This example selects the number of data points for the <literal>price</literal> property held in the length window:
			</para>
			<programlisting>select prevcount(price) from Trade#length(10)</programlisting>

			<para>
				By using the stream alias in the <literal>prevcount</literal> function the next example selects the count of trade events held in the length window:
			</para>
			<programlisting>select prevcount(trade) from Trade#length(10) as trade</programlisting>

			<para>
				The combination of the <literal>prevcount</literal> function and <literal>#groupwin</literal> returns the count of events in the given data window group. 
			</para>

			<para>
				This example statement outputs the number of events retaining the last 10 events per symbol:
			</para>
			<programlisting>select symbol, prevcount(price) from Trade#groupwin(symbol)#length(10)</programlisting>
			
			<sect3 xml:id="epl-single-row-function-ref-prevcount-restrictions">
				<title>Restrictions</title>
				<para>
					The following restrictions apply to the <literal>prev</literal> functions and its results:
				</para>
	
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The function always returns a <literal>null</literal> value for remove stream (old data) events.
						</para>
					</listitem>
					<listitem>
						<para>
							The function requires a data window, or a <literal>#groupwin</literal> and a data window. See <xref linkend="win-views"/> for built-in data windows.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>			
		</sect2>

		<sect2 xml:id="epl-single-row-function-ref-prior">
			<title>The <literal>Prior</literal> Function</title>

			<indexterm><primary>prior function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>prior</secondary></indexterm>
			<para>
				The <literal>prior</literal> function returns the property value of a prior event. 
				The first parameter is an expression returning a constant integer-typed value that denotes the i-th prior event in the natural order of arrival. 
				The second parameter is a property name for which the function returns the value for the prior event.
				The second parameter is a property name or stream name. If specifying a property name, the function returns the property value for the prior event. If specifying a stream name, the function returns the prior event underlying object.
			</para>

			<para>
				This example selects the value of the <literal>price</literal> property of the 2nd-prior event to the current Trade event.
			</para>
			<programlisting>select prior(2, price) from Trade</programlisting>

			<para>
				By using the stream alias in the <literal>prior</literal> function, the next example selects the trade event itself that is immediately prior to the current Trade event
			</para>
			<programlisting>select prior(1, trade) from Trade as trade</programlisting>

			<para>
				The <literal>prior</literal> function can be used on any event stream and does not require declaring a data window.  The function operates on the order of arrival of events by the event stream that provides the events.
			</para>

			<para>
				The next statement uses a time batch window to compute an average volume for 1 minute of Trade events, posting results every minute. The select-clause 
				employs the <literal>prior</literal> function to select the current average and the average before the current average:
			</para>
			<programlisting>select average, prior(1, average) 
    from TradeAverages#time_batch(1 min)#uni(volume)</programlisting>
	
		</sect2>

		<sect2 xml:id="epl-single-row-function-typeof">
			<title>The <literal>Type-Of</literal> Function</title>

			<indexterm><primary>type-of function</primary></indexterm>
			<indexterm><primary>functions</primary><secondary>type-of</secondary></indexterm>
			<para>
				The <literal>typeof</literal> function, when parameterized by a stream name, returns the event type name of the evaluated event which can be useful with variant streams. When parameterized by an expression or property name, the function returns the type name of the expression result or <literal>null</literal> if the expression result is null.
			</para>

			<para>
				In summary, the function determines the return type of the expression at runtime by evaluating the expression and returns the type name of the expression result.
			</para>

			<para>
				The <literal>typeof</literal> function is often used in conjunction with variant streams. A variant stream is a predefined stream into which events of multiple disparate event types can be inserted. The <literal>typeof</literal> function, when passed a stream name alias, returns the name of the event type of each event in the stream.
			</para>
			
			<para>
			    The following example elaborates on the use of variant streams with <literal>typeof</literal>. The first statement declares a variant stream <literal>SequencePatternStream</literal>:
			</para>
			<programlisting><![CDATA[create variant schema SequencePatternStream as *]]></programlisting>

			<para>
			    The next statement inserts all order events and is followed by a statement to insert all product events: 
			</para>
			<programlisting><![CDATA[insert into SequencePatternStream select * from OrderEvent;]]></programlisting>
			<programlisting><![CDATA[insert into SequencePatternStream select * from PriceEvent;]]></programlisting>
			
			<para>
				This example statement returns the event type name for each event in the variant stream:
			</para>
			<programlisting><![CDATA[select typeof(sps) from SequencePatternStream as sps]]></programlisting>

			<para>
				The next example statement detects a pattern by utilizing the <literal>typeof</literal> function to find pairs of order event immediately followed by product event:
			</para>
			<programlisting><![CDATA[select * from SequencePatternStream match_recognize(
  measures A as a, B as b
  pattern (A B)
  define A as typeof(A) = "OrderEvent",
         B as typeof(B) = "ProductEvent"
  )]]></programlisting>

			<para>
				When passing a property name to the <literal>typeof</literal> function, the function evaluates whether the property type is event type (a fragment event type). If the property type is event type, the function returns the type name of the event in the property value or <literal>null</literal> if not provided. 
				If the property type is not event type, the function returns the simple class name of the property value.
			</para>
			
			<para>
				When passing an expression to the <literal>typeof</literal> function, the function evaluates the expression and returns the simple class name of the expression result value or <literal>null</literal> if the expression result value is null.
			</para>
			<para>
				This example statement returns the simple class name of the value of the dynamic property <literal>prop</literal> of events in stream <literal>MyStream</literal>, or a <literal>null</literal> value if the property is not found for an event or the property value itself is <literal>null</literal>:
			</para>
			<programlisting><![CDATA[select typeof(prop?) from MyStream]]></programlisting>
			
			<para>
			    When using subclasses or interface implementations as event classes or when using Map-event type inheritance, the function returns the event type name provided when the class or Map-type event was registered, or if the event type was not registered, the function returns the fully-qualified class name.
			</para>
		</sect2>
	</sect1>		
	
	<sect1 xml:id="epl-function-aggregation">
		<title>Aggregation Functions</title>

		<indexterm><primary>aggregation functions</primary><secondary>overview</secondary></indexterm>
		
		<para>
			Aggregation functions are stateful and consider sets of events or value points. The <literal>group by</literal> clause is often used in conjunction with aggregation functions to group the result-set by one or more columns.
		</para>
		
		<para>
			Aggregation functions can be a column type for table declarations. This allows easy sharing of aggregated state, co-location of aggregations and other data 
			as well as co-aggregation by multiple statements into the same aggregation state.			
			Please see <xref linkend="nwtable-overview-table"/> for details.
		</para>

		<para>
			The EPL language extends the standard SQL aggregation functions by allowing filters and by further useful aggregation functions that can track a data window or compute event rates, for example. Your application may also add its own aggregation function as <xref linkend="custom-aggregation-function"/> describes.
		</para>
		
		<para>
			The EPL language allows each aggregation function to specify its own grouping criteria. Please find further information in <xref linkend="epl-grouping-agglocal"/>.
		</para>

		<para>
			The EPL language allows each aggregation function to specify its own filter criteria. Please find further information in <xref linkend="epl-grouping-aggfilter"/>.
		</para>

		<para>
			Aggregation values are always computed incrementally: Insert and remove streams result in aggregation value changes. The exceptions are on-demand queries and joins when using the <literal>unidirectional</literal> keyword. Aggregation functions are optimized to retain the minimal
				information necessary to compute the aggregated result, and to share aggregation state between eligible other aggregation functions in the same statement so that same-kind aggregation state is
				never held multiple times unless required.
		</para>
		
		<para>
			Most aggregation functions can also be used with unbound streams when no data window is specified. A few aggregation functions require a data window or named window as documented below.
		</para>
		
		<sect2 xml:id="epl-function-aggregation-std">
			<title>SQL-Standard Functions</title>

			<para>
				The SQL-standard aggregation functions are shown in below table.
			</para>
	
			<table frame="topbot" xml:id="epl-grouping-aggregate-func-table-SQL" revision="2">
				<title>Syntax and Results of SQL-Standard Aggregation Functions</title>
				<tgroup cols="2">
					<colspec colwidth="1*"/>
					<colspec colwidth="2.0*"/>
					<thead>
						<row>
							<entry>Aggregate Function</entry>
							<entry>Result</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><synopsis>avedev([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</synopsis></entry>
							<entry>
								<para>
									Mean deviation of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the mean deviation.
								</para>
							</entry>
						</row>
						<row>
							<entry><synopsis>avg([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</synopsis></entry>
							<entry>
								<para>
									Average of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the average.
								</para>
							</entry>
						</row>
						<row>
							<entry><synopsis>count([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</synopsis></entry>
							<entry>
								<para>
									Number of the (distinct) non-null values in the expression, returning a value of <literal>long</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for the count.
								</para>
							</entry>
						</row>
						<row>
							<entry><synopsis>count(* [, <emphasis>filter_expr</emphasis>])</synopsis></entry>
							<entry>
								<para>
									Number of events, returning a value of <literal>long</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for the count.
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<synopsis>max([all|distinct] <emphasis>expression</emphasis>)</synopsis>
								</para>
								<para>
									<synopsis>fmax([all|distinct] <emphasis>expression</emphasis>, <emphasis>filter_expr</emphasis>)</synopsis>
								</para>
							</entry>
							<entry>
								<para>
									Highest (distinct) value in the expression, returning a value of the same type as the expression itself returns.
								</para>
								<para>
									Use <literal>fmax</literal> to provide a filter expression that limits the values considered for computing the maximum.
								</para>
								<para>
								    Consider using <literal>maxby</literal> instead if return values must include additional properties.
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<synopsis>maxever([all|distinct] <emphasis>expression</emphasis>)</synopsis>
								</para>
								<para>
									<synopsis>fmaxever([all|distinct] <emphasis>expression</emphasis>, <emphasis>filter_expr</emphasis>)</synopsis>
								</para>
							</entry>
							<entry>
								<para>
									Highest (distinct) value - ever - in the expression, returning a value of the same type as the expression itself returns.
								</para>
								<para>
									Use <literal>fmaxever</literal> to provide a filter expression that limits the values considered for computing the maximum.
								</para>
								<para>
								    Consider using <literal>maxbyever</literal> instead if return values must include additional properties.
								</para>
							</entry>
						</row>
						<row>
							<entry><synopsis>median([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</synopsis></entry>
							<entry>
								<para>
									Median (distinct) value in the expression, returning a value of <literal>double</literal> type. Double Not-a-Number (NaN) values are ignored in the median computation.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the median.
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<synopsis>min([all|distinct] <emphasis>expression</emphasis>)</synopsis>
								</para>
								<para>
									<synopsis>fmin([all|distinct] <emphasis>expression</emphasis>, <emphasis>filter_expr</emphasis>)</synopsis>
								</para>
							</entry>
							<entry>
								<para>
									Lowest (distinct) value in the expression, returning a value of the same type as the expression itself returns.
								</para>
								<para>
									Use <literal>fmin</literal> to provide a filter expression that limits the values considered for computing the maximum.
								</para>
								<para>
								    Consider using <literal>minby</literal> instead if return values must include additional properties.
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<synopsis>minever([all|distinct] <emphasis>expression</emphasis>)</synopsis>
								</para>
								<para>
									<synopsis>fminever([all|distinct] <emphasis>expression</emphasis>, <emphasis>filter_expr</emphasis>)</synopsis>
								</para>
							</entry>
							<entry>
								<para>
									Lowest (distinct) value - ever - in the expression, returning a value of the same type as the expression itself returns.
								</para>
								<para>
									Use <literal>fminever</literal> to provide a filter expression that limits the values considered for computing the maximum.
								</para>
								<para>
								    Consider using <literal>minbyever</literal> instead if return values must include additional properties.
								</para>
							</entry>
						</row>
						<row>
							<entry><synopsis>stddev([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</synopsis></entry>
							<entry>
								<para>
									Standard deviation of the (distinct) values in the expression, returning a value of <literal>double</literal> type.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the standard deviation.
								</para>
							</entry>
						</row>
						<row>
							<entry><synopsis>sum([all|distinct] <emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</synopsis></entry>
							<entry>
								<para>
									Totals the (distinct) values in the expression, returning a value of <literal>long, double, float or integer</literal> type depending on the expression.
								</para>
								<para>
									The optional filter expression limits the values considered for computing the total.
								</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
	
			<para>
				If your application provides double-type values to an aggregation function, avoid using Not-a-Number (NaN) and infinity. Also when using double-type values, round-off errors (or rounding errors) may occur due to double-type precision. Consider rounding your result value to the desired precision.
			</para>
			
			<para>
			  Each of the aggregation functions above takes an optional filter expression as a parameter. The filter expression must return a boolean-type value and applies to the events considered for the aggregation. 
			  If a filter expression is provided, then only if the filter expression returns a value of true does the engine update the aggregation for that event or combination of events. 
			</para>
			
			<para>
			  Consider the following example, which computes the quantity fraction of buy orders among all orders:
			</para>
			<programlisting>select sum(quantity, side='buy') / sum(quantity) as buy_fraction from Orders</programlisting>

			<para>
				Use the <literal>fmin</literal> and <literal>fmax</literal> aggregation functions instead of the <literal>min</literal> and <literal>max</literal> aggregation functions when providing a filter expression (the <literal>min</literal> and <literal>max</literal> functions are also single-row functions).
			</para>

			<para>
			  The next example computes the minimum quantity for buy orders and a separate minimum quantity for sell orders:
			</para>
			<programlisting>select fmin(quantity, side='buy'), fmin(quantity, side = 'sell') from Orders</programlisting>
			
			<para>
			  This sample statement demonstrates specifying grouping criteria for an aggregation function using the <literal>group_by</literal> named parameter.
			  It computes, for the last one minute of orders, the ratio of orders per account compared to all orders:
			</para>
			<programlisting>select count(*)/count(*, group_by:()) as ratio from Orders#time(1 min) group by account</programlisting>
		</sect2>
	
		<sect2 xml:id="epl-function-aggregation-event">
			<title>Event Aggregation Functions</title>
		
			<para>
				The event aggregation functions return one or more events or event properties. When used with <literal>group by</literal> the event aggregation functions 
				return one or more events or event properties per group.
			</para>
			
			<para>
			  The <literal>sorted</literal> and the <literal>window</literal> event aggregation functions require that a data window or named window is declared for the applicable stream.
			  They cannot be used on unbound streams.
			</para>
				
			<para>
				The below table summarizes the event aggregation functions available:
			</para>
		
			<table frame="topbot" xml:id="event_aggregation_func_table" revision="2">
				<title>Event Aggregation Functions</title>
				<tgroup cols="2">
					<colspec colwidth="1.0*"/>
					<colspec colwidth="2.0*"/>
					<thead>
						<row>
							<entry>Function</entry>
							<entry>Result</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>first(...)</entry>
							<entry>
								<para>
									Returns the first event or an event property value of the first event.
								</para>
								<para>
									<xref linkend="epl-function-aggregation-event-first"/>.
								</para>
							</entry>
						</row>
						<row>
							<entry>last(...)</entry>
							<entry>
								<para>
									Returns the last event or an event property value of the last event.
								</para>
								<para>
									<xref linkend="epl-function-aggregation-event-last"/>.
								</para>
							</entry>
						</row>
						<row>
							<entry>maxby(criteria)</entry>
							<entry>
								<para>
									Returns the event with the highest sorted value according to criteria expressions.
								</para>
								<para>
									<xref linkend="epl-function-aggregation-event-maxby"/>.
								</para>
							</entry>
						</row>
						<row>
							<entry>maxbyever(criteria)</entry>
							<entry>
								<para>
									Returns the event with the highest sorted value, ever, according to criteria expressions.
								</para>
								<para>
									<xref linkend="epl-function-aggregation-event-maxbyever"/>.
								</para>
							</entry>
						</row>
						<row>
							<entry>minby(criteria)</entry>
							<entry>
								<para>
									Returns the event with the lowest sorted value according to criteria expressions.
								</para>
								<para>
									<xref linkend="epl-function-aggregation-event-minby"/>.
								</para>
							</entry>
						</row>
						<row>
							<entry>minbyever(criteria)</entry>
							<entry>
								<para>
									Returns the event with the lowest sorted value, ever, according to criteria expressions.
								</para>
								<para>
									<xref linkend="epl-function-aggregation-event-minbyever"/>.
								</para>
							</entry>
						</row>
						<row>
							<entry>sorted(criteria)</entry>
							<entry>
								<para>
									Returns events sorted according to criteria expressions.
								</para>
								<para>
									<xref linkend="epl-function-aggregation-event-sorted"/>.
								</para>
							</entry>
						</row>
						<row>
							<entry>window(...)</entry>
							<entry>
								<para>
									Returns all events or all event's property values.
								</para>
								<para>
									<xref linkend="epl-function-aggregation-event-window"/>.
								</para>
							</entry>
						</row>
					</tbody>
				  </tgroup>
				</table>		
	
				<para>
				   In connection with named windows and tables, event aggregation functions can also be used in <literal>on-select</literal>, 
				   selects with named window or table in the <literal>from</literal> clause, subqueries against named windows or tables and on-demand fire-and-forget queries.
				</para>
				
				<para>
				   The event aggregation functions are often useful in connection with enumeration methods and they can provide input events for enumeration. Please see <xref linkend="enumerationreference"/> for more information. 
				</para>
	
				<para>
					When comparing the <literal>last</literal> aggregation function to the <literal>prev</literal> function, the differences are as follows. The <literal>prev</literal> function is not an aggregation function and thereby not sensitive to the presence of <literal>group by</literal>. The <literal>prev</literal> function accesses data window contents directly and respects the sort order of the data window. The <literal>last</literal> aggregation function returns results based on arrival order and tracks data window contents in a separate shared data structure.
				</para>
	
				<para>
					When comparing the <literal>first</literal> aggregation function to the <literal>prevtail</literal> function, the differences are as follows. The <literal>prevtail</literal> function is not an aggregation function and thereby not sensitive to the presence of <literal>group by</literal>. The <literal>prevtail</literal> function accesses data window contents directly and respects the sort order of the data window. The <literal>first</literal> aggregation function returns results based on arrival order and tracks data window contents in a separate shared data structure.
				</para>
	
				<para>
					When comparing the <literal>window</literal> aggregation function to the <literal>prevwindow</literal> function, the differences are as follows. The <literal>prevwindow</literal> function is not an aggregation function and thereby not sensitive to the presence of <literal>group by</literal>. The <literal>prevwindow</literal> function accesses data window contents directly and respects the sort order of the data window. The <literal>window</literal> aggregation function returns results based on arrival order and tracks data window contents in a separate shared data structure.
				</para>
	
				<para>
					When comparing the <literal>count</literal> aggregation function to the <literal>prevcount</literal> function, the differences are as follows. The <literal>prevcount</literal> function is not an aggregation function and thereby not sensitive to the presence of <literal>group by</literal>.
				</para>
	
				<para>
					When comparing the <literal>last</literal> aggregation function to the <literal>nth</literal> aggregation function, the differences  are as follows. The <literal>nth</literal> aggregation function does not consider out-of-order deletes (for example with on-delete and sorted windows) and does not revert to the prior expression value when the last event or nth-event was deleted from a data window. The <literal>last</literal> aggregation function tracks the data window and reflects out-of-order deletes.
				</para>
	
				<para>
					From an implementation perspective, the <literal>first</literal>, <literal>last</literal> and <literal>window</literal> aggregation functions share a common data structure for each stream. 
					The <literal>sorted</literal>, <literal>minby</literal> and <literal>maxby</literal> aggregation functions share a common data structure for each stream. 
				</para>
			
			<sect3 xml:id="epl-function-aggregation-event-first">
				<title><literal>First</literal> Aggregation Function</title>
		
				<para>
					The synopsis for the <literal>first</literal> aggregation function is:
				</para>
				<synopsis><literal>first(</literal>*|<emphasis>stream</emphasis>.*|<emphasis>value_expression</emphasis> [, <emphasis>index_expression</emphasis>] [, filter:<emphasis>filter_expression</emphasis>])</synopsis>

				<para>
					The <literal>first</literal> aggregation function returns properties of the very first event. When used with <literal>group by</literal>, it returns properties of the first event for each group. When specifying an index expression, the function returns properties of the Nth-subsequent event to the first event, all according to order of arrival.
				</para>
				
				<para>
					The first parameter to the function is required and defines the event properties or expression result to return. The second parameter is an optional <emphasis>index_expression</emphasis> that must return an integer value used as an index to evaluate the Nth-subsequent event to the first event.
				</para>
				
				<para>
					You may specify the wildcard (<literal>*</literal>) character in which case the function returns the underlying event of the single selected stream. When selecting a single stream you may specify no parameter instead of wildcard. For joins and subqueries you must use the stream wildcard syntax below.
				</para>

				<para>
					You may specify the stream name and wildcard (<literal>*</literal>) character in the <emphasis>stream</emphasis><literal>.*</literal> syntax. This returns the underlying event for the specified stream.
				</para>

				<para>
					You may specify a <emphasis>value_expression</emphasis> to evaluate for the first event. The value expression may not select properties from multiple streams.
				</para>
				
				<para>
				    The <emphasis>index_expression</emphasis> is optional. If no index expression is provided, the function returns the first event. If present, the function evaluates the index expression to determine the value for N, and evaluates the Nth-subsequent event to the first event. A value of zero returns the first event and a value of 1 returns 
				    the event subsequent to the first event. You may not specify event properties in the index expression.
				</para>
				
				<para>
					The function returns <literal>null</literal> if there are no events or when the index is larger than the number of events held. When used with <literal>group by</literal>, it returns <literal>null</literal> if there are no events for that group or when the index is larger than the number of events held for that group.
				</para>

				<para>
					To explain, consider the statement below which selects the underlying event of the first sensor event held by the length window of 2 events.  
				</para>
				<programlisting>select first(*) from SensorEvent#length(2) </programlisting>
				
				<para>
				   Assume event E1, event E2 and event E3 are of type SensorEvent. When event E1 arrives the statement outputs the underlying event E1. When event E2 arrives the statement again outputs the underlying event E1. When event E3 arrives the statement outputs the underlying event E2, since 
				   event E1 has left the data window.
				</para>

				<para>
					The stream wildcard syntax is useful for joins and subqueries. This example demonstrates a subquery that returns the first SensorEvent when a DoorEvent arrives:
				</para>
				<programlisting>select (select first(se.*) from SensorEvent#length(2) as se) from DoorEvent </programlisting>
				
				<para>
					The following example shows the use of an index expression. The output value for <literal>f1</literal> is the temperature property value of the first event, the value for <literal>f2</literal> is the temperature property value of the second event:
				</para>
				<programlisting>select first(temperature, 0) as f1, first(temperature, 1) as f2
from SensorEvent#time(10 sec)</programlisting>

				<para>
					You may use dot-syntax to invoke a method on the first event. You may also append a property name using dot-syntax.
				</para>
			</sect3>

			<sect3 xml:id="epl-function-aggregation-event-last">
				<title><literal>Last</literal> Aggregation Function</title>
		
				<para>
					The synopsis for the <literal>last</literal> aggregation function is:
				</para>
				<synopsis><literal>last(</literal>*|<emphasis>stream</emphasis>.*|<emphasis>value_expression</emphasis> [, <emphasis>index_expression</emphasis>][, filter:<emphasis>filter_expression</emphasis>])</synopsis>

				<para>
					The <literal>last</literal> aggregation function returns properties of the very last event. When used with <literal>group by</literal>, it returns properties of the last event for each group. When specifying an index expression, the function returns properties of the Nth-prior event to the last event, all according to order of arrival.
				</para>

				<para>
					Similar to the <literal>first</literal> aggregation function described above, you may specify the wildcard (<literal>*</literal>) character, no parameter or stream name and wildcard (<literal>*</literal>) character or a <emphasis>value_expression</emphasis> to evaluate for the last event.
				</para>

				<para>
				    The <emphasis>index_expression</emphasis> is optional. If no index expression is provided, the function returns the last event. If present, the function evaluates the index expression to determine the value for N, and evaluates the Nth-prior event to the last event.  A value of zero returns the last event and a value of 1 returns 
				    the event prior to  the last event.
				    You may not specify event properties in the index expression.
				</para>
				
				<para>
					The function returns <literal>null</literal> if there are no events or when the index is larger than the number of events held. When used with <literal>group by</literal>, it returns <literal>null</literal> if there are no events for that group or when the index is larger than the number of events held for that group.
				</para>

				<para>
					The next statement selects the underlying event of the first and last sensor event held by the time window of 10 seconds:
				</para>
				<programlisting>select first(*), last(*) from SensorEvent#time(10 sec) </programlisting>
				
				<para>
					The statement shown next selects the last temperature (<literal>f1</literal>) and the prior-to-last temperature (<literal>f1</literal>) of sensor events in the last 10 seconds:
				</para>
				<programlisting>select last(temperature, 0) as f1, select last(temperature, 1) as f2
from SensorEvent#time(10 sec)</programlisting>
			</sect3>

			<sect3 xml:id="epl-function-aggregation-event-maxby">
				<title><literal>Maxby</literal> Aggregation Function</title>
				<indexterm><primary>maximum-by</primary></indexterm>
		
				<para>
					The synopsis for the <literal>maxby</literal> aggregation function is:
				</para>
				<synopsis><literal>maxby</literal>(<emphasis>sort_criteria_expression</emphasis> [asc/desc][, <emphasis>sort_criteria_expression</emphasis> [asc/desc]...][, filter:<emphasis>filter_expression</emphasis>])</synopsis>

				<para>
					The <literal>maxby</literal> aggregation function returns the greatest of all events, compared by using criteria expressions.
					When used with <literal>group by</literal>, it returns the greatest of all events per group.
				</para>
								
				<para>
					This example statement returns the sensor id and the temperature of the sensor event that had the highest temperature among all sensor events:
				</para>
				<programlisting>select maxby(temperature).sensorId, maxby(temperature).temperature from SensorEvent</programlisting>
				
				<para>
					The next EPL returns the sensor event that had the highest temperature and the sensor event that had the lowest temperature, per zone, among the last 10 seconds of sensor events:
				</para>
				<programlisting>select maxby(temperature), minby(temperature) from SensorEvent#time(10 sec) group by zone</programlisting>
				
				<para>
					Your EPL may specify multiple criteria expressions. If the sort criteria expression is descending please append the <literal>desc</literal> keyword.
				</para>

				<para>
					The following EPL returns the sensor event with the highest temperature and if there are multiple sensor events with the highest temperature the query
					returns the sensor event that has the newest timestamp value:
				</para>
				<programlisting>select maxby(temperature asc, timestamp desc) from SensorEvent</programlisting>

				<para>
				  Event properties that are listed in criteria expressions must refer to the same event stream and cannot originate from different event streams.
				</para>
				
				<para>
				  If your query does not define a data window and does not refer to a named window, the semantics of <literal>maxby</literal> are the same as <literal>maxbyever</literal>.
				</para>
			</sect3>

			<sect3 xml:id="epl-function-aggregation-event-maxbyever">
				<title><literal>Maxbyever</literal> Aggregation Function</title>
		
				<para>
					The synopsis for the <literal>maxbyever</literal> aggregation function is:
				</para>
				<synopsis><literal>maxbyever</literal>(<emphasis>sort_criteria_expression</emphasis> [asc/desc][, <emphasis>sort_criteria_expression</emphasis> [asc/desc]...][, filter:<emphasis>filter_expression</emphasis>])</synopsis>

				<para>
					The <literal>maxbyever</literal> aggregation function returns the greatest of all events that ever occurred, compared by using criteria expressions.
					When used with <literal>group by</literal>, it returns the greatest of all events that ever occurred per group.
				</para>
								
				<para>
					Compared to the <literal>maxby</literal> aggregation function the <literal>maxbyever</literal> does not consider the data window or named window contents
					and instead considers all arriving events.
				</para>
				
				<para>
					The next EPL computes the difference, per zone, between the maximum temperature considering all events and the maximum temperature considering
					only the events in the last 10 seconds:
				</para>
				<programlisting>select maxby(temperature).temperature - maxbyever(temperature).temperature 
from SensorEvent#time(10) group by zone</programlisting>
			</sect3>

			<sect3 xml:id="epl-function-aggregation-event-minby">
				<title><literal>Minby</literal> Aggregation Function</title>
				<indexterm><primary>minimum-by</primary></indexterm>
		
				<para>
					The synopsis for the <literal>minby</literal> aggregation function is:
				</para>
				<synopsis><literal>minby</literal>(<emphasis>sort_criteria_expression</emphasis> [asc/desc][, <emphasis>sort_criteria_expression</emphasis> [asc/desc]...][, filter:<emphasis>filter_expression</emphasis>])</synopsis>

				<para>
					Similar to the <literal>maxby</literal> aggregation function, the <literal>minby</literal> aggregation function returns the lowest of all events, compared by using criteria expressions.
					When used with <literal>group by</literal>, it returns the lowest of all events per group.
				</para>
								
				<para>
					Please review the section on <literal>maxby</literal> for more information.
				</para>
			</sect3>

			<sect3 xml:id="epl-function-aggregation-event-minbyever">
				<title><literal>Minbyever</literal> Aggregation Function</title>
		
				<para>
					Similar to the <literal>maxbyever</literal> aggregation function, the <literal>minbyever</literal> aggregation function returns the lowest of all events that ever occurred, compared by using criteria expressions.
					When used with <literal>group by</literal>, it returns the lowest of all events per group that ever occured.
				</para>
								
				<para>
					Please review the section on <literal>maxbyever</literal> for more information.
				</para>
			</sect3>

			<sect3 xml:id="epl-function-aggregation-event-sorted">
				<title><literal>Sorted</literal> Aggregation Function</title>
				<indexterm><primary>ordered</primary></indexterm>
				<indexterm><primary>sorted</primary></indexterm>

				<para>
					The synopsis for the <literal>sorted</literal> aggregation function is:
				</para>
				<synopsis><literal>sorted</literal>(<emphasis>sort_criteria_expression</emphasis> [asc/desc][, <emphasis>sort_criteria_expression</emphasis> [asc/desc]...][, filter:<emphasis>filter_expression</emphasis>])</synopsis>

				<para>
					The <literal>sorted</literal> aggregation function maintains a list of events sorted according to criteria expressions.
					When used with <literal>group by</literal>, it maintains a list of events sorted according to criteria expressions per group.
				</para>
								
				<para>
					The sample EPL listed next returns events sorted according to temperature ascending for the same zone:
				</para>
				<programlisting>select sorted(temperature) from SensorEvent group by zone</programlisting>
								
				<para>
					Your EPL may specify multiple criteria expressions. If the sort criteria expression is descending please append the <literal>desc</literal> keyword.
				</para>

				<para>
					Enumeration methods can be useful in connection with <literal>sorted</literal> as the function provides the sorted events as input.
				</para>
				
				<para>
				    This EPL statement finds the sensor event that when sorted according to temperature is the first sensor event for a Friday timestamp among sensor events for the same zone:
				</para>
				<programlisting>select sorted(temperature).first(v => timestamp.getDayOfWeek()=6)
from SensorEvent</programlisting>

				<para>
				  Event properties that are listed in criteria expressions must refer to the same event stream and cannot originate from different event streams.
				</para>
				
				<para>
				  If used in a regular select statement, the use of <literal>sorted</literal> requires that your EPL defines a data window for the stream or utilizes a named window.
				</para>
			</sect3>

			<sect3 xml:id="epl-function-aggregation-event-window">
				<title><literal>Window</literal> Aggregation Function</title>
		
				<para>
					The synopsis for the <literal>window</literal> aggregation function is:
				</para>
				<synopsis><literal>window(</literal>*|<emphasis>stream</emphasis>.*|<emphasis>value_expression</emphasis> [, filter:<emphasis>filter_expression</emphasis>])</synopsis>

				<para>
					The <literal>window</literal> aggregation function returns all rows. When used with <literal>group by</literal>, it returns the rows for each group.
				</para>

				<para>
					Similar to the <literal>first</literal> aggregation function described above, you may specify the wildcard (<literal>*</literal>) character or stream name and wildcard (<literal>*</literal>) character or a <emphasis>value_expression</emphasis> to evaluate for all events.
				</para>

				<para>
					The function returns <literal>null</literal> if there are no rows. When used with <literal>group by</literal>, it returns <literal>null</literal> if there are no rows for that group.
				</para>

				<para>
					The next statement selects the underlying event of all events held by the time window of 10 seconds:
				</para>
				<programlisting>select window(*) from SensorEvent#time(10 sec) </programlisting>
				
				<para>
					If used in a regular select statement, the <literal>window</literal> aggregation function requires that your stream is bound by a data window or a named window. You may not use the <literal>window</literal> aggregation function on unbound streams with the exception of on-demand queries or subqueries.
				</para>

				<para>
					This example statement assumes that the <literal>OrderWindow</literal> named window exists. For each event entering or leaving the <literal>OrderWindow</literal> named window
					it outputs the total amount removing negative amounts:
				</para>
				<programlisting>select window(*).where(v => v.amount > 0).aggregate(0d, (r, v) => r + v.amount) from OrderWindow </programlisting>
			</sect3>
		</sect2>
		
		<sect2 xml:id="epl-function-aggregation-approx">
			<title>Approximation Aggregation Functions</title>

			<para>
				Approximation aggregation functions are aggregations that perform approximate analysis. Compared to the previously-introduced aggregation functions,
				the functions discussed here have a degree of accuracy and probabilistic behavior.
			</para>
			
			<sect3 xml:id="epl-function-aggregation-approx-countminsketch">
				<title>Count-Min Sketch</title>
				
				<para>
				  Count-min sketch (or CM sketch) is a probabilistic sub-linear space streaming algorithm (source: Wikipedia).
				  Count-min sketch computes an approximate frequency, without retaining distinct values in memory, making the algorithm suitable for summarizing very large spaces of distinct values.
				  The estimated count can be used for estimated top-K and estimated heavy-hitters, for example.
				</para>
				
				<para> 
					The original and detail of the algorithm is described in the paper by Graham Cormode and S. Muthukrishnan. An improved data stream summary: 
					The Count-min sketch and its applications (2004. 10.1016/j.jalgor.2003.12.001).
				</para>

				<para>
					Count-min sketch can only be used with tables and is not available as an aggregation function other than in a table declaration.
				</para>
				
				<para>
					Count-min sketch does not consider events leaving a data window and does not process a remove stream.
				</para>
				
				<sect4 xml:id="epl-function-aggregation-approx-countminsketch-declare">
					<title>Declaration</title>
					<para>
						The table column type for Count-min sketch is <literal>countMinSketch</literal>. 
					</para>
					
					<para>
						For example, the next EPL declares a table that holds a Count-min sketch (does not provision a top-K):
					</para>
					<programlisting>create table WordCountTable(wordcms countMinSketch())</programlisting>

					<para>
						You can parameterize the algorithm by providing a JSON-format structure to the declaration.
						The available parameters are all optional:
					</para>
					
					<table frame="topbot" xml:id="countminsketch_params" revision="2">
						<title>Count-min Sketch Parameters</title>
						<tgroup cols="2">
							<colspec colwidth="0.2*"/>
							<colspec colwidth="0.8*"/>
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry><literal>epsOfTotalCount</literal></entry>
									<entry>
										<para>
											Specifies the accuracy (number of values counted * accuracy >= number of errors) of type double.
										</para>
										<para>
											This value defaults to 0.0001.
										</para>
									</entry>
								</row>
								<row>
									<entry><literal>confidence</literal></entry>
									<entry>
										<para>
											Provides the certainty with which you reach the accuracy of type double.
										</para>
										<para>
											The default is 0.99.
										</para>
									</entry>
								</row>
								<row>
									<entry><literal>seed</literal></entry>
									<entry>
										<para>
											A seed value for computing hash codes of type integer.
										</para>
										<para>
											This default is 123456.
										</para>
									</entry>
								</row>
								<row>
									<entry><literal>topk</literal></entry>
									<entry>
										<para>
											The number of top-K values as an integer. If null, the algorithm maintains no top-K list.
										</para>
										<para>
											This value defaults to null (no top-K available).
										</para>
									</entry>
								</row>
								<row>
									<entry><literal>agent</literal></entry>
									<entry>
										<para>
											The agent is an extension API class that can interact with Count-min sketch state and also receives the value objects.
											The agent defines the type of the values that can be counted. The default agent only allows string-type values
											and utilizes UTF-16 charset encoding.
										</para>
										<para>
											The default agent is <literal>com.espertech.esper.client.util.CountMinSketchAgentStringUTF16</literal>.
										</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>		
				
					<para>
						The next example EPL declares all available parameters:
					</para>
					<programlisting>create table WordCountTable (wordcms countMinSketch({
  epsOfTotalCount: 0.000002,
  confidence: 0.999,
  seed: 38576,
  topk: 20,
  agent: 'com.mycompany.CountMinSketchCustomAgent'
}))</programlisting>

					<para>
						The default for the <literal>topk</literal> parameter is <literal>null</literal>. Thereby the engine by default does not compute top-K.
						By specifying a positive integer value for <literal>topk</literal> the algorithm maintains a list of values representing the top estimated counts.
					</para>
					
					<para>
						By default, the Count-min sketch group of aggregation functions operates on string-type values only. 						
						The aggregation function allows registering an agent that can handle any other type of value objects and that allows overriding behavior. 
						The agent class must implement the interface <literal>com.espertech.esper.client.util.CountMinSketchAgent</literal>.
						Please see the JavaDoc for implementing an agent. The agent API is an extension API and is subject to change between versions.
					</para>
				</sect4>
				
				<sect4 xml:id="epl-function-aggregation-approx-countminsketch-add">
					<title>Counting Values</title>
					<para>
						The <literal>countMinSketchAdd</literal> function counts value(s). It expects a single parameter expression returning the value(s) to be counted.
						The function can only be used with statements that utilize <literal>into table</literal> and can accept a <literal>filter:</literal> filter expression as a parameter.
					</para>
					
					<para>
						This example EPL counts words:
					</para>
					<programlisting>into table WordCountTable select countMinSketchAdd(word) as wordcms from WordEvent</programlisting>									
				</sect4>

				<sect4 xml:id="epl-function-aggregation-approx-countminsketch-freq">
					<title>Estimating Current Count</title>
					<para>
						The <literal>countMinSketchFrequency</literal> function returns an estimated count for a given value.
						It expects a single parameter expression returning the value(s) for which to estimate and return the long-type count.
						The function can only be used as a table-access function against a table column that declares the aggregation <literal>countMinSketch</literal>.
					</para>
					
					<para>
						The next example EPL returns, when a <literal>EstimateWordCountEvent</literal> event arrives, the estimated frequency of a given word:
					</para>
					<programlisting>select WordCountTable.wordcms.countMinSketchFrequency(word) from EstimateWordCountEvent</programlisting>
				</sect4>

				<sect4 xml:id="epl-function-aggregation-approx-countminsketch-topk">
					<title>Obtaining Top-K</title>
					<para>
						The <literal>countMinSketchTopK</literal> function returns top-K. The function expects no parameters.
						The function can only be used as a table-access function against a table column that declares the aggregation <literal>countMinSketch</literal>
						and only if the Count-min sketch was parameterized with a non-null <literal>topk</literal> parameter (the default is <literal>null</literal>, see declaration above).
					</para>
					
					<para>
						The function returns an array of <literal>com.espertech.esper.client.util.CountMinSketchTopK</literal>.
					</para>
					
					<para>
						The following EPL outputs top-K every 10 seconds:
					</para>
					<programlisting>select WordCountTable.wordcms.countMinSketchTopk() from pattern[every timer:interval(10 sec)]</programlisting>
				</sect4>
				
				<sect4 xml:id="epl-function-aggregation-approx-agent">
					<title>Agent API Example</title>

					<para>
						We provide a sample agent code that handles String-type values below. The complete code is available for class <literal>CountMinSketchAgentStringUTF16</literal> as part of sources.
					</para>
					
					<programlisting>public class CountMinSketchAgentStringUTF16 implements CountMinSketchAgent {
  public Class[] getAcceptableValueTypes() {
    return new Class[] {String.class};
  }

  public void add(CountMinSketchAgentContextAdd ctx) {
    String text = (String) ctx.getValue();
    if (text == null) {
      return;
    }
    byte[] bytes = toBytesUTF16(text);
    ctx.getState().add(bytes, 1);  // increase count by 1
  }

  public Long estimate(CountMinSketchAgentContextEstimate ctx) {
    String text = (String) ctx.getValue();
    if (text == null) {
      return null;
    }
    byte[] bytes = toBytesUTF16(text);
    return ctx.getState().frequency(bytes);
  }
}</programlisting>
				</sect4>
			</sect3>				
		</sect2>

		<sect2 xml:id="epl-function-aggregation-add">
			<title>Additional Aggregation Functions</title>

			<para>
				Esper provides the following additional aggregation functions beyond those in the SQL standard:
			</para>
		
			<table frame="topbot" xml:id="epl-grouping-aggregate-func-table-ext" revision="2">
				<title>Syntax and Results of EPL Aggregation Functions</title>
				<tgroup cols="2">
					<colspec colwidth="1*"/>
					<colspec colwidth="2.0*"/>
					<thead>
						<row>
							<entry>Aggregate Function</entry>
							<entry>Result</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<para>
									countever(<emphasis>*</emphasis> [, <emphasis>filter_expr</emphasis>])
								</para>
								<para>
									countever(<emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])
								</para>
							</entry>
							<entry>
								<para>
									The <literal>countever</literal> aggregation function returns the number of events ever. 
									When used with <literal>group by</literal> it returns the number of events ever for that group.
								</para>				
								<para>
									When used with a data window, the result of the function does not change as data points leave a data window. Use the <literal>count(*)</literal> or <literal>prevcount</literal> function to return counts relative to a data window.
								</para>
								<para>
									The optional filter expression limits the values considered for counting rows. The <literal>distinct</literal> keyword is not allowed. When an expression is provided
									instead of wildcard, counts the non-null values.
								</para>
								<para>
									The next example statement outputs the count-ever for sell orders:
								</para>
								<programlisting>select countever(*, side='sell') from Order</programlisting>
							</entry>
						</row>
						<row>
							<entry>firstever(<emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									The <literal>firstever</literal> aggregation function returns the very first value ever. When used with <literal>group by</literal> it returns the first value ever for that group.
								</para>				
								<para>
									When used with a data window, the result of the function does not change as data points leave a data window. Use the <literal>first</literal> or <literal>prevtail</literal> function to return values relative to a data window.
								</para>
								<para>
									The optional filter expression limits the values considered for retaining the first-ever value.
								</para>
								<para>
									The next example statement outputs the first price ever for sell orders:
								</para>
								<programlisting>select firstever(price, side='sell') from Order</programlisting>
							</entry>
						</row>
						<row>
							<entry>lastever(<emphasis>expression</emphasis> [, <emphasis>filter_expr</emphasis>])</entry>
							<entry>
								<para>
									Returns the last value or last value per group, when used with <literal>group by</literal>.
								</para>
								<para>
									This sample statement outputs the total price, the first price and the last price per symbol for the last 30 seconds of events and every 5 seconds:
								</para>
								<programlisting>select symbol, sum(price), lastever(price), firstever(price)
from StockTickEvent#time(30 sec) 
group by symbol
output every 5 sec</programlisting>
								<para>
									When used with a data window, the result of the function does not change as data points leave a data window (for example when all data points leave the data window). Use the <literal>last</literal> or <literal>prev</literal> function to return values relative to a data window.
								</para>
								<para>
									The optional filter expression limits the values considered for retaining the last-ever value.
								</para>
								<para>
									The next example statement outputs the last price (ever) for sell orders:
								</para>
								<programlisting>select lastever(price, side='sell') from Order</programlisting>
							</entry>
						</row>
						<row>
							<entry>leaving([filter:<emphasis>filter_expression</emphasis>])</entry>
							<entry>
								<para>
									Returns true when any remove stream data has passed, for use in the <literal>having</literal> clause to output only when a data window has filled.
								</para>
								<para>
									The <literal>leaving</literal> aggregation function is useful when you want to trigger output after a data window has a remove stream data point. Use the <literal>output after</literal> syntax as an alternative to output after a time interval.
								</para>
								<para>
									This sample statement uses <literal>leaving()</literal> to output after the first data point leaves the data window, ignoring the first datapoint:
								</para>
								<programlisting>select symbol, sum(price) 
from StockTickEvent#time(30 sec) 
having leaving()</programlisting>
							</entry>
						</row>
						<row>
							<entry>nth(<emphasis>expression</emphasis>, <emphasis>N_index</emphasis> [, filter:<emphasis>filter_expression</emphasis>])</entry>
							<entry>
								<para>
									Returns the Nth oldest element; If N=0 returns the most recent value. If N=1 returns the value before the most recent value. If N is larger than the events held in the data window for this group, returns null.
								</para>
								<para>
									A maximum N historical values are stored, so it can be safely used to compare
									recent values in data windows with a large number of events without incurring excessive overhead.
								</para>
								<para>
									As compared to the <literal>prev</literal> row function, this aggregation function works within the current <literal>group by</literal> group, see <xref linkend="processingmodel_aggregation"/>.
								</para>
								<para>
									This statement outputs every 2 seconds the groups that have new data and their last price and the previous-to-last price:
								</para>
								<programlisting>select symbol, nth(price, 1), last(price) 
from StockTickEvent 
group by symbol
output last every 2 sec</programlisting>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									rate(<emphasis>number_of_seconds</emphasis> [, filter:<emphasis>filter_expression</emphasis>])
								</para>
							</entry>
							<entry>
								<para>
									Returns an event arrival rate per second over the provided number of seconds, computed based on engine time.								
								</para>
								<para>
									Returns null until events fill the number of seconds. Useful with <literal>output snapshot</literal> to output a current rate. This function footprint is for use without a data window onto the stream(s).
								</para>
								<para>
									A sample statement to output, every 2 seconds, the arrival rate per second considering the last 10 seconds of events is shown here:
								</para>
								<programlisting>select rate(10) from StockTickEvent
output snapshot every 2 sec</programlisting>
								<para>
									The aggregation function retains an engine timestamp value for each arriving event.
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									rate(<emphasis>timestamp_property</emphasis>[, <emphasis>accumulator</emphasis>] [, filter:<emphasis>filter_expression</emphasis>])
								</para>
							</entry>
							<entry>
								<para>
									Returns an event arrival rate over the data window including the last remove stream event. The <emphasis>timestamp_property</emphasis>
									is the name of a long-type property of the event that provides a timestamp value.
								</para>
								<para>
									The first parameter is a property name or expression providing millisecond timestamp values.
								</para>
								<para>
									The optional second parameter is a property or expression for computing an accumulation rate: If a value is provided as a second parameter then the accumulation rate for that quantity is returned (e.g. turnover in dollars per second).
								</para>
								<para>
									This footprint is designed for use with a data window and requires a data window declared onto the stream. Returns null until events start leaving the window.
								</para>
								<para>
									This sample statement outputs event rate for each group (symbol) with fixed sample size of four events 
									(and considering the last event that left). The <literal>timestamp</literal> event property must be part of the event for this to work.
								</para>
								<programlisting>select colour, rate(timestamp) as rate 
from StockTickEvent#groupwin(symbol)#length(4) 
group by symbol</programlisting>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		
			<para>
				Built-in aggregation functions can be disabled via configuration (see <xref linkend="config-engine-expression-extendedagg"/>). A custom aggregation function of the same name as a built-on function may be registered to override the built-in function.
			</para>
		</sect2>
	</sect1>		

	<sect1 xml:id="epl-function-user-defined">
		<title>User-Defined Functions</title>
		
		<indexterm><primary>user-defined function</primary></indexterm>
		<indexterm><primary>functions</primary><secondary>user-defined</secondary></indexterm>
		<indexterm><primary>UDF</primary><secondary>user-defined function</secondary></indexterm>
		 <para>
			 A user-defined function (UDF) is a single-row function that can be invoked anywhere as an expression itself or within an expresson. The function must simply be a public static method
			 that the classloader can resolve at statement creation time. The engine resolves the function reference at statement creation time and verifies parameter types.
		 </para>
		 
		<para>
		  For information on calling external services via instance method invocation, please see <xref linkend="variable_eventtype"/>. For invoking methods on events, please see <xref linkend="epl-from-clause-stream-name"/>
		</para>

		<para>
			You may register your own function name for the user-defined function. Please see the instructions in <xref linkend="custom-singlerow-function"/> for registering a function name for a user-defined single-row function.
		</para>
		
		<para>
			A single-row function that has been registered with a function name can simply be referenced as <emphasis>function_name</emphasis><literal>(</literal><emphasis>parameters</emphasis><literal>)</literal> thus EPL statements can be less cluttered as no class name is required. 
			The engine also optimizes evaluation of such registered single-row functions when used in filter predicate expressions as described in <xref linkend="custom-single-filter-optimizable"/>.
		</para>

		<para>
			An example EPL statement that utilizes the <literal>discount</literal> function is shown next (assuming that function has been registered).
		</para>
		<programlisting><![CDATA[select discount(quantity, price) from OrderEvent]]></programlisting>

		<para>
			When selecting from a single stream, use the wildcard <literal>(*)</literal> character to pass the underlying event:
		</para>
		<programlisting><![CDATA[select discount(*) from OrderEvent]]></programlisting>

		<para>
			Alternatively use the stream alias or EPL pattern tag to pass an event:
		</para>
		<programlisting><![CDATA[select discount(oe) from OrderEvent as oe]]></programlisting>

		 <para>
			 User-defined functions can be also be invoked on instances of an event: Please see <xref linkend="epl-from-clause-stream-name"/> to invoke event instance methods on a named stream.
		 </para>
		 
		 <para>
			 Note that user-defined functions (not single-row functions) are candidate for caching their return result if the parameters passed are constants and they are not used chained. Please see below for details and configuration.
		 </para>

		 <para>
			 The example below assumes a class <literal>MyClass</literal> that exposes a public static method <literal>myFunction</literal> accepting 2 parameters, and
			 returing a numeric type such as <literal>double</literal>.
		 </para>
		 
<programlisting><![CDATA[select 3 * com.mycompany.MyClass.myFunction(price, volume) as myValue 
from StockTick#time(30 sec)]]></programlisting>

		 <para>
			 User-defined functions also take array parameters as this example shows. The section on <xref linkend="epl-operator-ref-array"/> outlines in more detail the types of arrays produced.
		 </para>		
		<programlisting><![CDATA[select * from RFIDEvent where com.mycompany.rfid.MyChecker.isInZone(zone, {10, 20, 30})]]></programlisting>

		<para>
			Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism for user-controlled imports of classes and packages as outlined in <xref linkend="config-class--package-imports"/>.
		</para>

		 <para>
			 User-defined functions can return any value including <literal>null</literal>, Java objects or arrays. Therefore user-defined functions can serve to transform, convert or map events, or to extract information and assemble further events.
		 </para>

		 <para>
			 The following statement is a simple pattern that looks for events of type E1 that are followed by events of type E2. It assigns the tags "e1" and "e2" that the function can use to assemble a final event for output:
		 </para> 
		<programlisting><![CDATA[select MyLib.mapEvents(e1, e2) from pattern [every e1=E1 -> e2=E2]]]></programlisting>

		 <para>
			 User-defined functions may also be chained: If a user-defined function returns an object then the object can itself be the target of the next function call and so on.
		 </para> 

		 <para>
			 Assume that there is a <literal>calculator</literal> function in the <literal>MyLib</literal> class that returns a class which provides the <literal>search</literal> method taking two parameters. The EPL
			 that takes the result of the <literal>calculator</literal> function and that calls the <literal>search</literal> method on the result and returns its return value is shown below:
		 </para> 
		<programlisting><![CDATA[select MyLib.calculator().search(zonevariable, zone) from RFIDEvent]]]></programlisting>

		 <para>
			 A user-defined function should be implemented thread-safe. 
		 </para> 

		<sect3 xml:id="epl-function-user-defined-converting">
			<title>Event Type Conversion via User-Defined Function</title>
			 <para>
				 A function that converts from one event type to another event type is shown in the next example. The first statement declares a stream that consists of MyEvent events. The second statement employs a conversion function to convert MyOtherEvent events to events of type MyEvent:
			 </para> 
			<programlisting><![CDATA[insert into MyStream select * from MyEvent
	insert into MyStream select MyLib.convert(other) from MyOtherEvent as other]]></programlisting>
	
			 <para>
				 In the example above, assuming the event classes MyEvent and MyOtherEvent are Java classes, the static method should have the following footprint:
			 </para> 
			 <programlisting><![CDATA[public static MyEvent convert(MyOtherEvent otherEvent)]]></programlisting>
		</sect3>
		
		<sect3 xml:id="epl-function-user-defined-cached">
			<title>User-Defined Function Result Cache</title>
			 <para>
				 For user-defined functions that take no parameters or only constants as parameters the engine automatically caches the return result of the function, and invokes the function only once. This is beneficial to performance 
				 if your function indeed returns the same result for the same input parameters.
			</para>
			 <para>
				 You may disable caching of return values of user-defined functions via configuration as described in <xref linkend="config-engine-expression-udfcache"/>.
			</para>
		</sect3>

		<sect3 xml:id="epl-function-user-defined-matching">
			<title>Parameter Matching</title>
			 <para>
				 EPL follows Java standards in terms of widening, performing widening automatically in cases where widening type conversion is allowed without loss of precision, for both boxed and primitive types.				 
			 </para> 
			 
			 <para>
				 When user-defined functions are overloaded, the function with the best match is selected based on how well the arguments to a function can match up with the parameters, giving preference to the function that requires the least number of widening conversions.
			 </para>

			 <para>
				 User-defined functions that can receive an arbitrary number of parameter values can use <emphasis>varargs</emphasis>, i.e. can define a function such as <literal>function(T arg1, T... args) {...}</literal>.
			 </para>

			 <para>
				 Boxing and unboxing of arrays is not supported in UDF as it is not supported in Java. For example, an array of <literal>Integer</literal> and an array of <literal>int</literal> are not compatible types.
			 </para>

			<para>
			  When passing the event or underlying event to your method, either declare the parameter to take <literal>EventBean</literal> (i.e. <literal>myfunc(EventBean event)</literal>) 
			  or as the underlying event type (i.e. <literal>myfunc(OrderEvent event)</literal>).
			</para>

			 <para>
				 When using <literal>{}</literal> array syntax in EPL, the resulting type is always a boxed type: <literal>"{1, 2}"</literal> is an array of <literal>Integer</literal> (and not <literal>int</literal> since it may contain null values), <literal>"{1.0, 2d}"</literal> is an array of <literal>Double</literal> and <literal>"{'A', "B"}"</literal> is an array of <literal>String</literal>, while <literal>"{1, "B", 2.0}"</literal> is an array of <literal>Object</literal> (<literal>Object[]</literal>).
			 </para>
		</sect3>

		<sect3 xml:id="epl-function-user-defined-receivectx" revision="1">
			<title>Receiving a Context Object</title>

			<para>
			  Esper can pass an object containing contextual information such as statement name, function name, engine URI and context partition id to your
			  method. The container for this information is <literal>EPLMethodInvocationContext</literal> in package <literal>com.espertech.esper.client.hook</literal>.
			  Please declare your method to take <literal>EPLMethodInvocationContext</literal> as the last parameter. The engine then passes the information along.
			</para>
			
			<para> 
			  A sample method footprint and EPL are shown below:
			</para>					
			<programlisting><![CDATA[public static double computeSomething(double number, EPLMethodInvocationContext context) {...}]]></programlisting>
			<programlisting><![CDATA[select MyLib.computeSomething(10) from MyEvent]]></programlisting>
		</sect3>
	</sect1>

	<sect1 xml:id="functionreference-transpose">
		<title>Select-Clause <literal>Transpose</literal> Function</title>
		
		<para>
		  The <literal>transpose</literal> function is only valid in the select-clause and indicates that the result of the parameter expression should become the underlying event object of the output event.
		</para>
		
		<para>
		  The <literal>transpose</literal> function takes a single expression as a parameter. The result object of the parameter expression is subject to transposing as described below.
		</para>

		<para>
		  The function can be useful with <literal>insert into</literal> to allow an object returned by an expression to become the event itself in the output stream.
		</para>
		
		<para>
		  Any expression returning a Java object can be used with the <literal>transpose</literal> function. Typical examples for expressions are a static method invocation, the result of an enumeration method, a plug-in single row function or a subquery. 
		</para>

		<para>
		  The examples herein assume that a single-row function by name <literal>makeEvent</literal> returns an <literal>OrderEvent</literal> instance (a POJO object, not shown).
		</para>
		
		<para>
		  The following EPL takes the result object of the invocation of the <literal>makeEvent</literal> method (assumed to be an OrderEvent instance) and returns the OrderEvent instance as the underlying event of the output event:
		</para>
		<programlisting><![CDATA[select transpose(makeEvent(oi)) from OrderIndication oi]]></programlisting>

		<para>
		  Your select-clause can select additional properties or expressions. In this case the output event underlying object is a pair of the expression result object and the additional properties.
		</para>
		
		<para>
		  The next EPL also selects the <literal>origin</literal> property of the order indication event. The output event is a pair of the OrderEvent instance and a map containing the property name and value of origin:
		</para>
		<programlisting><![CDATA[select origin, transpose(makeEvent(oi)) from OrderIndication oi]]></programlisting>

		<para>
		  If the <literal>transpose</literal> function is not a top-level function, i.e. if it occurs within another expression or within any other clause then the select-clause, the function simply returns the expression result of the parameter expression.
		</para>

		<sect2 xml:id="functionreference-transpose-insert-into">
			<title>Transpose with Insert-Into</title>

			<para>
				  You may insert transposed output events into another stream.
			</para>
			
			<para>
				  If the stream name in the insert-into clause is already associated to an event type, the engine checks whether the event type associated to the stream name provided in the insert-into clause matches the event type associated to the object returned by the expression. If the stream name in the insert-into clause is not already associated to an existing event type the engine associates a new event type using the stream name provided in the insert-into clause.
			</para>
			
			<para>
				The type returned by the expression must match the event representation that is defined for the stream, i.e. must be a subtype or implementation of the respective class (POJO, object-array or Map).
			</para>

			<para>
				For example, the next statement associates the stream name <literal>OrderEvent</literal> with a class. Alternatively this association can be achieved via static or runtime configuration API:
			</para>
			<programlisting><![CDATA[create schema OrderEvent as com.mycompany.OrderEvent]]></programlisting>
			
			<para>
				An EPL statement can insert into the <literal>OrderEvent</literal> stream the <literal>OrderEvent</literal> instance returned by the <literal>makeEvent</literal> method, as follows:
			</para>
			<programlisting><![CDATA[insert into OrderEvent select transpose(makeEvent(oi)) from OrderIndication oi]]></programlisting>
			
			<para>
				It is not valid to select additional properties or expressions in this case, as they would not be part of the output event. The following is not valid:
			</para>
			<programlisting><![CDATA[// not valid
insert into OrderEvent select origin, transpose(makeEvent(oi)) from OrderIndication oi]]></programlisting>
		</sect2>
	</sect1>

</chapter>