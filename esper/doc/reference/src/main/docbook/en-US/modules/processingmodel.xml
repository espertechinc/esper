<chapter xml:id="processingmodel" version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="./" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">

    <title>Basic Concepts</title>

    <sect1 xml:id="processingmodel_intro" revision="1">
        <title>Introduction</title>
        
		<para>
			For NEsper .NET also see <xref linkend="appendix_dotnet_processingmodel_intro"/>.
		</para>
		
		<para>
			Esper is a container for EPL queries. EPL queries are continuous query statements that analyze events and time and that detect situations. Esper contains the EPL queries as it manages their lifecycle and execution.
		</para>
		
		<para>
			You interact with Esper by managing EPL queries and callbacks and by sending events and advancing time.
		</para>
				
		<table frame="topbot">
			<title>Interacting With Esper</title>
			<tgroup cols="2">
				<colspec colwidth="0.2*"/>
				<colspec colwidth="1*"/>
				<thead>
					<row>
						<entry>What</entry>
						<entry>How</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>EPL</entry>
						<entry>First, deploy EPL queries, please refer to <xref linkend="epl_clauses"/> and the API at <xref linkend="api-administrative"/>.</entry>
					</row>
					<row>
						<entry>Callbacks</entry>
						<entry>Second, attach executable code that your application provides to receive output, please refer to <xref linkend="api-receive-results"/>.</entry>
					</row>
					<row>
						<entry>Events</entry>
						<entry>Next, send events using the runtime API, please refer to <xref linkend="api-runtime"/>.</entry>
					</row>
					<row>
						<entry>Time</entry>
						<entry>Next, advance time using the runtime API or system time, please refer to <xref linkend="api-controlling-time"/>.</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
						
		<para>
			Esper contains queries like so:
		</para>

        <figure xml:id="processingmodel_into_querycontainerpic">
			<title>Esper Is a Query Container</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_querycontainer.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
		
		<para>
			When time passes or an event arrives Esper evaluates only those queries that need to see such event or time. Esper analyzes EPL queries, performs query planning and utilizes data structures to avoid unneeded evaluation.
		</para>

		<para>
			EPL queries can be partitioned. A partitioned query can have multiple partitions. For example, there could be partition for each room in a building. 
			For a building with 10 rooms you could have one EPL query that has 10 partitions. Please refer to <xref linkend="context"/>.
		</para>

		<para>
			An EPL query that is not partitioned implicitly has one partition. Upon creating the un-partitioned EPL query Esper allocates the single partition. Upon destroying the un-partitioned EPL query Esper destroys the partition.
		</para>
		
		<para>
			A partition (or <emphasis>context partition</emphasis>) is where Esper keeps the state. In the picture above there are three un-partitioned queries and one partitioned query that has three partitions.
		</para>

		<para>
			The next sections discuss various easily-understood EPL queries. 
			The sections illustrate how queries behave, the information that Esper passes to callbacks (the output) and what information Esper remembers for queries (the <emphasis>state</emphasis>, all state lives in a partition).
			The sample queries assume an event type by name <literal>Withdrawal</literal> that has <literal>account</literal> and <literal>amount</literal> properties.
		</para>
	</sect1>
		
    <sect1 xml:id="processingmodel_basicselect" revision="1">
        <title>Basic Select</title>

		<para>
			This EPL query selects all <literal>Withdrawal</literal> events.
		</para>
		<programlisting><![CDATA[select * from Withdrawal]]></programlisting>
		
		<para>
			Upon a new <literal>Withdrawal</literal> event arriving, Esper passes the arriving event, unchanged and the same object reference, to callbacks.
			After that Esper effectively forgets the current event.
		</para>

		<para>
			The diagram below shows a series of <literal>Withdrawal</literal> events (1 to 6) arriving over time.
			In the picture the <literal>W</literal><subscript>n</subscript> stands for a specific <literal>Withdrawal</literal> event arriving. The number in parenthesis is the withdrawal amount.
		</para>
		
        <figure xml:id="processingmodel_into_basicselect">
			<title>EPL Select Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicselect.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>

		<para>
			For this query, Esper remembers no information and does not remember any events. A query where Esper does not need to remember any information at all is a query without state (a <emphasis>stateless</emphasis> query).
		</para>			
		
		<para>
			The term <emphasis>insert stream</emphasis> is a name for the stream of new events that are arriving. The insert stream in this example is the stream of arriving Withdrawal events.
		</para>
	</sect1>
	
    <sect1 xml:id="processingmodel_basicaggregation" revision="1">
        <title>Basic Aggregation</title>
        
        <para>
			An aggregation function is a function that groups multiple events together to form a single value. Please find more information at <xref linkend="epl-function-aggregation"/>.
        </para>

		<para>
			This query selects a count and a total amount of all Withdrawal events.
		</para>
		<programlisting><![CDATA[select count(*), sum(amount) from Withdrawal]]></programlisting>
		
		<para>
			Upon a new <literal>Withdrawal</literal> event arriving, Esper increments the count and adds the amount to a running total. It passes the new count and total to callbacks.
			After that Esper effectively forgets the current event and does not remember any events at all, but does remember the current count and total.
		</para>
		
        <figure xml:id="processingmodel_into_basicaggregation">
			<title>EPL Select Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicaggregation.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>

		<para>
			Here, Esper only remembers the current number of events and the total amount. 
			The count is a single long-type value and the total is a single double-type value (assuming <literal>amount</literal> is a double-value, the total can be <literal>BigDecimal</literal> as applicable).
			 This query is not stateless and the state consists of a long-typed value and a double-typed value.
		</para>
			
		<para>
			Upon a new <literal>Withdrawal</literal> event arriving, Esper increases the count by one and adds the amount to the running total. Esper does not re-compute the count and total because it does not remember events.
			In general, Esper does not re-compute aggregations (unless otherwise indicated). Instead, Esper adds (increments, enters, accumulates) data to aggregation state and subtracts (decrements, removes, reduces, decreases) from aggregation state.
		</para>
	</sect1>
	
    <sect1 xml:id="processingmodel_basicfilter" revision="1">
        <title>Basic Filter</title>

		<para>
			Place filter expressions in parenthesis after the event type name. For further information see <xref linkend="epl-from-clause-filter"/>.
		</para>
		
		<para>
			This statement selects <literal>Withdrawal</literal> events that have an amount of 200 or higher:
		</para>
		<programlisting><![CDATA[select * from Withdrawal(amount >= 200)]]></programlisting>
		
		<para>
			Upon a new <literal>Withdrawal</literal> event with an amount of 200 or higher arriving, Esper passes the arriving event to callbacks. 
		</para>
		
        <figure xml:id="processingmodel_into_basicfilter">
			<title>EPL Filter Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicfilter.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>

		<para>
			For this query, Esper remembers no information and does not remember any events. 
		</para>			
		
		<para>
			You may ask what happens for <literal>Withdrawal</literal> events with an amount of less than 200. The answer is that the EPL query itself does not even see such events. This is because Esper knows to discard such events right away
			and the EPL query does not even know about such events. Esper discards unneeded events very fast enabled by EPL query analysis, planning and suitable data structures.
		</para>
	</sect1>

    <sect1 xml:id="processingmodel_basicfilterwithagg" revision="1">
        <title>Basic Filter and Aggregation</title>

		<para>
			This statement selects the count and the total amount for <literal>Withdrawal</literal> events that have an amount of 200 or higher:
		</para>
		<programlisting><![CDATA[select count(*), sum(amount) from Withdrawal(amount >= 200)]]></programlisting>
		
		<para>
			Upon a new <literal>Withdrawal</literal> event with an amount of 200 or higher arriving, Esper increments the count and adds the amount to the running total. Esper passes the count and total to callbacks.
		</para>

        <figure xml:id="processingmodel_into_basicfilterwithagg">
			<title>EPL Filter and Aggregation Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicfilteragg.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>

		<para>
			In this example Esper only remembers the count and total and again does not remember events. The engine discards <literal>Withdrawal</literal> events with an amount of less than 200.
		</para>				
	</sect1>

    <sect1 xml:id="processingmodel_basicwindow" revision="1">
        <title>Basic Data Window</title>

		<para>
			A <emphasis>data window</emphasis>, or <emphasis>window</emphasis> for short, retains events for the purpose of aggregation, join, match-recognize patterns, subqueries, iterating via API  and output-snapshot.
			A data window defines which subset of events to retain. For example, a length window keeps the last N events and a time window keeps the last N seconds of events.
			See <xref linkend="epl-views"/> for details.
		</para>
		
		<para>
			This query selects all <literal>Withdrawal</literal> events and instructs Esper to remember the last five events.
		</para>
		<programlisting><![CDATA[select * from Withdrawal#length(5)]]></programlisting>
		
		<para>
			Upon a new <literal>Withdrawal</literal> event arriving, Esper adds the event to the length window. It also passes the same event to callbacks.
		</para>
		
        <figure xml:id="processingmodel_into_basicdatawindow">
			<title>EPL Basic Data Window Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicwindow.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
        
		<para>
			Upon arrival of event W<subscript>6</subscript>, event W<subscript>1</subscript> leaves the length window. We use the term <emphasis>expires</emphasis> to say that an event leaves a data window.
			We use the term <emphasis>remove stream</emphasis> to describe the stream of events leaving a data window.
		</para>

		<para>
			Esper remembers up to five events in total (the last five events). At the start of the query the data window is empty.
			By itself, keeping the last five events may not sound useful. But in connection with a join, subquery or match-recognize pattern for example a data window tells the engine which events you want to query.
		</para>

        <note>
			By default the engine only delivers the insert stream to listeners and observers. 
			EPL supports optional <literal>istream</literal>, <literal>irstream</literal> and <literal>rstream</literal> keywords for select- and insert-into clauses to control which streams to deliver, see <xref linkend="epl-select-using-istream-rstream"/>.
        </note>
	</sect1>

    <sect1 xml:id="processingmodel_basicwindowagg" revision="1">
        <title>Basic Data Window and Aggregation</title>

		<para>
			This query outputs the count and total of the last five <literal>Withdrawal</literal> events.
		</para>
		<programlisting><![CDATA[select count(*), sum(amount) from Withdrawal#length(5)]]></programlisting>
		
		<para>
			Upon a new <literal>Withdrawal</literal> event arriving, Esper adds the event to the length window, increases the count by one and adds the amount to the current total amount. 
			Upon a <literal>Withdrawal</literal> event leaving the data window, Esper decreases the count by one and subtracts its amount from the current total amount. 
			It passes the running count and total to callbacks.
		</para>
		
        <figure xml:id="processingmodel_into_basicwindowagg">
			<title>EPL Basic Data Window and Aggregation Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicwindowagg.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
        
        <para>
			Before the arrival of event W<subscript>6</subscript> the current count is five and the running total amount is 1000. Upon arrival of event W<subscript>6</subscript> the following takes place:
        </para>
        <orderedlist>
			<ns:listitem>
				<para>
						Esper determines that event W<subscript>1</subscript> leaves the length window.
				</para>
			</ns:listitem>
			<ns:listitem>
				<para>
						To account for the new event W<subscript>6</subscript>, Esper increases the count by one and adds 300 to the running total amount.
				</para>
			</ns:listitem>
			<ns:listitem>
				<para>
						To account for the expiring event W<subscript>1</subscript>, Esper decreases the count by one and subtracts 500 from the running total amount.
				</para>
			</ns:listitem>
			<ns:listitem>
				<para>
						The output is a count of five and a total of 800 as a result of <literal>1000 + 300 - 500</literal>.
				</para>
			</ns:listitem>
		</orderedlist>
			
		<para>
			Esper adds (increments, enters, accumulates) insert stream events into aggregation state and subtracts (decrements, removes, reduces, decreases) remove stream events from aggregation state.
			It thus maintains aggregation state in an incremental fashion.
		</para>

		<para>
			For this query, once the count reaches 5, the count will always remain at 5.
		</para>
        
		<para>
			The information that Esper remembers for this query is the last five events and the current long-typed count and double-typed total.
		</para>
		
		<tip>
			<para>
				Use the <literal>irstream</literal> keyword to receive both the current as well as the previous aggregation value for aggregating queries.
			</para>
		</tip>
	</sect1>

    <sect1 xml:id="processingmodel_basicfilterwindowagg" revision="1">
        <title>Basic Filter, Data Window and Aggregation</title>
        <para>
			The following query outputs the count and total of the last five <literal>Withdrawal</literal> events considering only those <literal>Withdrawal</literal> events that have an amount of at least 200:
        </para>
        
        <programlisting><![CDATA[select count(*), sum(amount) from Withdrawal(amount>=200)#length(5)]]></programlisting>

		<para>
			Upon a new <literal>Withdrawal</literal> event arriving, and only if that Withdrawal event has an amount of 200 or more, Esper adds the event to the length window, increases the count by one and adds the amount to the current total amount. 
			Upon a <literal>Withdrawal</literal> event leaving the data window, Esper decreases the count by one and subtracts its amount from the current total amount. 
			It passes the running count and total to callbacks.
		</para>
        
        <figure xml:id="processingmodel_into_basicfilterwindowagg">
			<title>EPL Basic Filter, Data Window and Aggregation Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicfilterwindowagg.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
    </sect1>
    
    <sect1 xml:id="processingmodel_basicwhereclause" revision="1">
        <title>Basic Where-Clause</title>
        
        <para>
			For queries without a data window, the where-clause behaves the same as the filter expressions that are placed in parenthesis.
        </para>
        
        <para>
			The following two queries are fully equivalent because of the absence of a data window (the <literal>....</literal> means any select-clause expressions):
        </para>
			<programlisting><![CDATA[select .... from Withdrawal(amount > 200)
// equivalent to
select .... from Withdrawal where amount > 200]]></programlisting>
		
		<note>
			<para>
				In Esper, the where-clause is typically used for correlation in a join or subquery. Filter expressions should be placed right after the event type name in parenthesis.
			</para>
		</note>
		
        <para>
			The next statement applies a where-clause to Withdrawal events. Where-clauses are discussed in more detail in <xref linkend="epl-where-clause"/>.
        </para>

        <programlisting><![CDATA[select * from Withdrawal#length(5) where amount >= 200]]></programlisting>

        <para>
			The where-clause applies to both new events and expiring events. Only events that pass the where-clause are passed to callbacks.
        </para>

        <figure xml:id="processingmodel_into_basicwhere">
			<title>EPL Basic Where-Clause Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicwhere.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
    </sect1>

    <sect1 xml:id="processingmodel_basictimewindow" revision="1">
        <title>Basic Time Window and Aggregation</title>
        
        <para>
			A time window is a data window that extends the specified time interval into the past. More information on time windows can be found at <xref linkend="view-win-time"/>.
        </para>
        			
		<para>
			The next query selects the count and total amount of <literal>Withdrawal</literal> events considering the last four seconds of events.
		</para>
		<programlisting><![CDATA[select count(*), sum(amount) as total from Withdrawal#time(4)]]></programlisting>
		
		<para>
			The diagram starts at a given time <literal>t</literal> and displays the contents of the time window at <literal>t + 4</literal> and <literal>t + 5 seconds</literal> and so on.
		</para>

        <figure xml:id="processingmodel_into_basictimewindow">
			<title>EPL Basic Time Window Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basictimewindowagg.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
        
		<para>
			The activity as illustrated by the diagram:
		</para>
		
		<orderedlist>
			<listitem>
				<para>
					At time <literal>t + 4 seconds</literal> an event <literal>W<subscript>1</subscript></literal> arrives and the output is a count of one and a total of 500.
				</para>
			</listitem>
			<listitem>
				<para>
					At time <literal>t + 5 seconds</literal> an event <literal>W<subscript>2</subscript></literal> arrives and the output is a count of two and a total of 600.
				</para>
			</listitem>
			<listitem>
				<para>
					At time <literal>t + 6.5 seconds</literal> an event <literal>W<subscript>3</subscript></literal> arrives and the output is a count of three and a total of 800.
				</para>
			</listitem>
			<listitem>
				<para>
					At time <literal>t + 8 seconds</literal> event <literal>W<subscript>1</subscript></literal> expires and the output is a count of two and a total of 300.
				</para>
			</listitem>
		</orderedlist>

		<para>
			For this query Esper remembers the last four seconds of <literal>Withdrawal</literal> events as well as the long-typed count and the double-typed total amount.
		</para>
				
		<tip>
			<para>
				Time can have a millisecond or microsecond resolution.
			</para>
		</tip>						
	</sect1>
        
    <sect1 xml:id="processingmodel_basicpartition" revision="1">
        <title>Basic Partitioned Query</title>
        
        <para>
			The queries discussed so far are not partitioned. A query that is not partitioned implicitly has one partition. 
			Upon creating the un-partitioned EPL query Esper allocates the single partition and it destroys the partition when your application destroys the query.
        </para>
        
        <para>
			A partitioned query is handy for batch processing, sessions, resetting and start/stop of your analysis. For partitioned queries you must specify a context. A context defines how partitions are allocated and destroyed.
			Additional information about partitioned queries and contexts can be found at <xref linkend="context"/>.
		</para>

		<para>
			We shall have a single partition that starts immediately and ends after four seconds:
		</para>
		<programlisting><![CDATA[create context Batch4Seconds start @now end after 4 sec]]></programlisting>

		<para>
			The next query selects the count and total amount of <literal>Withdrawal</literal> events that arrived since the last reset (resets are at <literal>t</literal>, <literal>t+4</literal>, <literal>t+8</literal> as so on), resetting each four seconds:
		</para>
		<programlisting><![CDATA[context Batch4Seconds select count(*), total(amount) from Withdrawal]]></programlisting>
		
        <figure xml:id="processingmodel_into_basicpartitioned">
			<title>EPL Basic Partitioned Query Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicpartitioned.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
        
		<para>
			At time <literal>t + 4 seconds</literal> and <literal>t + 8 seconds</literal> the engine destroys the current partition. This discards the current count and running total. 
			The engine immediately allocates a new partition and the count and total start fresh at zero.
		</para>
		
		<para>
			For this query Esper only remembers the count and running total, and the fact how long a partition lives.
		</para>
	</sect1>

    <sect1 xml:id="processingmodel_basicoutputlimited" revision="1">
        <title>Basic Output-Rate-Limited Query</title>
        
        <para>
			All the previous queries had continuous output. In other words, in each of previous queries output occurred as a result of a new event arriving.
			Use output rate limiting to output when a condition occurs, as described in <xref linkend="epl-output-rate"/>.
		</para>

		<para>
			The next query outputs the last count and total of all <literal>Withdrawal</literal> events every four seconds:
		</para>
		<programlisting><![CDATA[select count(*), total(amount) from Withdrawal output last every 4 seconds]]></programlisting>
		
        <figure xml:id="processingmodel_into_basicoutputlimited">
			<title>EPL Basic Output-Rate-Limited Query Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicoutputratelimited.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
        
		<para>
			At time <literal>t + 4 seconds</literal> and <literal>t + 8 seconds</literal> the engine outputs the last aggregation values to callbacks.
		</para>
		
		<para>
			For this query Esper only remembers the count and running total, and the fact when output shall occur.
		</para>		
	</sect1>

    <sect1 xml:id="processingmodel_basicpartitionedandoutputlimited" revision="1">
        <title>Basic Partitioned and Output-Rate-Limited Query</title>
        
        <para>
			Use a partitioned query with output rate limiting to output-and-reset. This allows you to form batches, analyze a batch and then forget all such state in respect to that batch, continuing with the next batch. 
		</para>
		
		<para>
			The next query selects the count and total amount of <literal>Withdrawal</literal> events that arrived within the last four seconds at the end of four seconds, resetting after output:
		</para>
		<programlisting><![CDATA[create context Batch4Seconds start @now end after 4 sec]]></programlisting>
		<programlisting><![CDATA[context Batch4Seconds select count(*), total(amount) from Withdrawal output last when terminated]]></programlisting>

        <figure xml:id="processingmodel_into_basicpartitionedandoutputlimited">
			<title>EPL Basic Partitioned and Output-Rate-Limited Query Example Input and Output Flow</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="images/refdoc_procmodel_basicpartitionedandoutputlimited.png" scale="60" align="center"/>
				</imageobject>
			</mediaobject>
        </figure>
        
		<para>
			At time <literal>t + 4 seconds</literal> and <literal>t + 8 seconds</literal> the engine outputs the last aggregation values to callbacks, and resets the current count and total.
		</para>
		
		<para>
			For this query Esper only remembers the count and running total, and the fact when the output shall occur and how long a partition lives.
		</para>		
	</sect1>
		
	<sect1 xml:id="processingmodel_namedwindows" revision="1">
		<title>Basic Named Windows and Tables</title>
			
		<para>
			A named window is a global data window that can take part in many queries, and that can be selected-from, inserted- into and deleted-from by multiple EPL queries.
			Named windows can be queried with fire-and-forget queries through the API and inward-facing JDBC driver.
			The documentation link is <xref linkend="nwtable"/>.
		</para>
		
		<para>
			Create a named window, for example, to hold alarm information:
		</para>
		<programlisting><![CDATA[create window AlertNamedWindow as (origin string, priority string, alarmNumber long)]]></programlisting>
		
		<para>
			Use on-merge to insert and update the named window.
		</para>
		<programlisting><![CDATA[on Alert as a1 merge AlertNamedWindow as a2 where a1.alarmNumber = a2.alarmNumber
  when not matched then insert select *]]></programlisting>

		<para>
			The following query outputs the current count of rows in the named window:
		</para>
		<programlisting><![CDATA[select count(*) from AlertNamedWindow]]></programlisting>

		<para>
			Tables are similar to named window however have a well-defined primary-key and can share aggregated state, while named windows only share a subset of events.
		</para>
	</sect1>

	<sect1 xml:id="processingmodel_aggregation" revision="1">
		<title>Basic Aggregated Query Types</title>

		<para>
			The expressions in the select-clause, the use of aggregation functions and the group-by-clause are relevant to EPL query design.
			The overview herein is especially relevant to joins, on-trigger, output-rate-limiting and batch data windows.
		</para>
		
		<itemizedlist>
			<ns:listitem>
				<para>If your query only selects aggregation values, the engine outputs one row (or zero rows in a join).</para>
			</ns:listitem>
			<ns:listitem>
				<para>Without a group-by clause, if your query selects non-aggregated values along with aggregation values, the engine outputs a row per event.</para>
			</ns:listitem>
			<ns:listitem>
				<para>With a group-by clause, if your query selects non-aggregated values that are all in the group-by-clause, the engine outputs a row per group.</para>
			</ns:listitem>
			<ns:listitem>
				<para>With a group-by clause, if your query selects non-aggregated values and not all non-aggregated values are in the group-by-clause, the engine outputs a row per event.</para>
			</ns:listitem>
		</itemizedlist>

		<para>
			EPL allows each aggregation function to specify its own grouping criteria. Please find further information in <xref linkend="epl-grouping-agglocal"/>.
			The documentation provides output examples for query types in <xref linkend="appendix_outputspec"/>, and the next sections outlines each query type.
		</para>

		<para>
			The examples below assume <literal>BankInformationWindow</literal> is a named window defined elsewhere.
			The examples use a join to illustrate. Joins are further described in <xref linkend="epl-join"/>.
		</para>

		<sect2 xml:id="processingmodel_aggregation_batch_unagg" revision="1">
			<title>Un-Aggregated and Un-Grouped</title>

			<para>
				An example statement for the un-aggregated and un-grouped case is as follows:
			</para>
			<programlisting><![CDATA[select * from Withdrawal unidirectional, BankInformationWindow]]></programlisting>
			<para>
				Upon a <literal>Withdrawal</literal> event coming in, the number of output rows is the number of rows in the <literal>BankInformationWindow</literal>.
			</para>
			
			<para>
				The appendix provides a complete example including input and output events over time at <xref linkend="outputspec-simple"/>.
			</para>				
		</sect2>

		<sect2 xml:id="processingmodel_aggregation_batch_full_agg" revision="1">
			<title>Fully Aggregated and Un-Grouped</title>

			<para>
				If your statement only selects aggregation values and does not group, your statement may look as the example below:
			</para>
			<programlisting><![CDATA[select sum(amount) 
from Withdrawal unidirectional, BankInformationWindow]]></programlisting>
			<para>
				Upon a <literal>Withdrawal</literal> event coming in, the number of output rows is always zero or one.
			</para>
			<para>
				The appendix provides a complete example including input and output events over time at <xref linkend="outputspec-rowforall"/>.
			</para>				
			<para>
				If any aggregation functions specify the <literal>group_by</literal> parameter and a dimension, for example <literal>sum(amount, group_by:account)</literal>, 
				the query executes as an aggregated and grouped query instead.
			</para>
		</sect2>

		<sect2 xml:id="processingmodel_aggregation_batch_event_agg" revision="1">
			<title>Aggregated and Un-Grouped</title>

			<para>
				If your statement selects non-aggregated properties and aggregation values, and does not group, your statement may be similar to this statement:
			</para>
			<programlisting><![CDATA[select account, sum(amount) 
from Withdrawal unidirectional, BankInformationWindow]]></programlisting>
			<para>
				Upon a <literal>Withdrawal</literal> event coming in, the number of output rows is the number of rows in the <literal>BankInformationWindow</literal>.
			</para>
			<para>
				The appendix provides a complete example including input and output events over time at <xref linkend="outputspec-aggregateall"/>.
			</para>				
		</sect2>

		<sect2 xml:id="processingmodel_aggregation_batch_group_agg" revision="1">
			<title>Fully Aggregated and Grouped</title>

			<para>
				If your statement selects aggregation values and all non-aggregated properties in the <literal>select</literal> clause are listed in the <literal>group by</literal> clause, then your statement may look similar to this example:
			</para>
			<programlisting><![CDATA[select account, sum(amount) 
from Withdrawal unidirectional, BankInformationWindow
group by account]]></programlisting>
			<para>
				Upon a <literal>Withdrawal</literal> event coming in, the number of output rows is one row per unique account number.
			</para>
			<para>
				The appendix provides a complete example including input and output events over time at <xref linkend="outputspec-groupedrowpergroup"/>.
			</para>				
			<para>
				If any aggregation functions specify the <literal>group_by</literal> parameter and a dimension other than <literal>group by</literal> dimension(s), 
				for example <literal>sum(amount, group_by:accountCategory)</literal>, the query executes as an aggregated and grouped query instead.
			</para>
		</sect2>

		<sect2 xml:id="processingmodel_aggregation_batch_event_agg_group" revision="1">
			<title>Aggregated and Grouped</title>

			<para>
				If your statement selects non-aggregated properties and aggregation values, and groups only some properties using the <literal>group by</literal> clause,  your statement may look as below:
			</para>
			<programlisting><![CDATA[select account, accountName, sum(amount) 
from Withdrawal unidirectional, BankInformationWindow
group by account]]></programlisting>
			<para>
				Upon a <literal>Withdrawal</literal> event coming in, the number of output rows is the number of rows in the <literal>BankInformationWindow</literal>.
			</para>
			<para>
				The appendix provides a complete example including input and output events over time at <xref linkend="outputspec-aggregategrouped"/>.
			</para>				
		</sect2>
	</sect1>
	
	<sect1 xml:id="processingmodel_matchrecognizepattern" revision="1">
		<title>Basic Match-Recognize Patterns</title>
		
		<para>
			Esper offers the standardized match-recognize syntax for finding patterns among events. A match-recognize pattern is very similar to a regular-expression pattern. 
		</para>
		
		<para>
			The below query is a sample match-recognize pattern. It detects a pattern that may be present in the events held by the named window as declared above. It looks for two immediately-followed events, i.e. with no events in-between for the same origin. The first of the two events must have high priority and the second of the two events must have medium priority.
		</para>
		
			<programlisting><![CDATA[select * from AlertNamedWindow
  match_recognize (
    partition by origin
    measures a1.origin as origin, a1.alarmNumber as alarmNumber1, a2.alarmNumber as alarmNumber2
    pattern (a1 a2)
    define
      a1 as a1.priority = 'high',
      a2 as a2.priority = 'medium'
)]]></programlisting>
	</sect1>
	
	<sect1 xml:id="processingmodel_eplpattern" revision="1">
		<title>Basic EPL Patterns</title>
		
		<para>
			Esper offers the EPL pattern language, a versatile and expressive syntax for finding time and property relationships between events of many streams.
		</para>
		
		<para>
			Event patterns match when an event or multiple events occur that match the pattern's definition, in a bottom-up fashion.
			Pattern expressions can consist of filter expressions combined with pattern operators. Expressions can contain further nested pattern expressions by including the nested expression(s) in parenthesis.
		</para>
		
		<para>
			There are five types of operators:
		</para>
		<orderedlist>
			<ns:listitem>
				<para>Operators that control pattern finder creation and termination: <literal>every</literal></para>
			</ns:listitem>
			<ns:listitem>
				<para>Logical operators: <literal>and</literal>, <literal>or</literal>, <literal>not</literal></para>
			</ns:listitem>
			<ns:listitem>
				<para>Temporal operators that operate on event order: <literal>-&gt;</literal> (the followed-by operator)</para>
			</ns:listitem>
			<ns:listitem>
				<para>Guards are where-conditions that cause termination of pattern subexpressions, such as <literal>timer:within</literal></para>
			</ns:listitem>
			<ns:listitem>
				<para>Observers that observe time events, such as <literal>timer:interval</literal> (an interval observer), <literal>timer:at</literal> (a crontab-like observer)</para>
			</ns:listitem>
		</orderedlist>
		
		<para>
			A sample pattern that alerts on each IBM stock tick with a price greater than 80 and within the next 60 seconds:
		</para>
		<programlisting><![CDATA[every StockTickEvent(symbol="IBM", price>80) where timer:within(60 seconds)]]></programlisting>

		<para>
			A sample pattern that alerts every five minutes past the hour:
		</para>
		<programlisting><![CDATA[every timer:at(5, *, *, *, *)]]></programlisting>

		<para>
			A sample pattern that alerts when event A occurs, followed by either event B or event C:
		</para>
		<programlisting><![CDATA[A -> ( B or C)]]></programlisting>

		<para>
			A pattern where a property of a following event must match a property from the first event:
		</para>
		<programlisting><![CDATA[every a=EventX -> every b=EventY(objectID=a.objectID)]]></programlisting>
	</sect1>

	<sect1 xml:id="processingmodel_indexes" revision="1">
		<title>Basic Indexes</title>
		
		<sect2 xml:id="processingmodel_indexes_kinds" revision="1">
			<title>Index Kinds</title>
			<para>
				Esper, depending on the EPL statements, builds and maintains two kinds of indexes: filter indexes and event indexes.
			</para>
			
			<para>
				Esper builds and maintains indexes for efficiency so as to achieve good performance.
			</para>
			
			<para>
				The following table compares the two kinds of indexes:
			</para>
			<table frame="topbot">
				<title>Kinds of Indexes</title>
				<tgroup cols="3">
					<colspec colwidth="0.5*"/>
					<colspec colwidth="1*"/>
					<colspec colwidth="1*"/>
					<thead>
						<row>
							<entry></entry>
							<entry>Filter Indexes</entry>
							<entry>Event Indexes</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Improve the speed of</entry>
							<entry>Matching incoming events to currently-active filters that shall process the event</entry>
							<entry>Lookup of rows</entry>
						</row>
						<row>
							<entry>Similar to</entry>
							<entry>A structured registry of callbacks; or content-based routing</entry>
							<entry>Database index</entry>
						</row>
						<row>
							<entry>Index stores values of</entry>
							<entry>Values provided by expressions</entry>
							<entry>Values for certain column(s)</entry>
						</row>
						<row>
							<entry>Index points to</entry>
							<entry>Currently-active filters</entry>
							<entry>Rows</entry>
						</row>
						<row>
							<entry>Comparable to </entry>
							<entry>A sieve or a switchboard</entry>
							<entry>An index in a book</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect2>
		
		<sect2 xml:id="processingmodel_indexes_filterindexes" revision="1">
			<title>Filter Indexes</title>
			
			<para>
				Filter indexes organize filters so that they can be searched efficiently. Filter indexes link back to the statement that the filter(s) come from. 
			</para>

			<para>
			    We use the term <emphasis>filter</emphasis> or <emphasis>filter criteria</emphasis> to mean the selection predicate, such as <literal>symbol=“google” and price > 200 and volume > 111000</literal>. 
			    Statements provide filter criteria in the <literal>from</literal>-clause, and/or in EPL patterns and/or in context declarations. 
			    Please see <xref linkend="epl-from-clause-filter"/>, <xref linkend="pattern-filter"/> and <xref linkend="context_def_condition_filter"/>.
			</para>

			<para>
				When the engine receives an event, it consults the filter indexes to determine which statements, if any, must process the event.
			</para>
			
			<para>
				The purpose of filter indexes is to enable:
			</para>

			<itemizedlist>
				<ns:listitem>
					<para>Efficient matching of events to only those statements that need them.</para>
				</ns:listitem>
				<ns:listitem>
					<para>Efficient discarding of events that are not needed by any statement.</para>
				</ns:listitem>
				<ns:listitem>
					<para>Efficient evaluation with best case approximately O(1) to O(log n) i.e. in the best case executes in approximately the same time regardless of the size of the input data set  which is the number of active filters.</para>
				</ns:listitem>
			</itemizedlist>
			
			<para>
				Filter index building is a result of the engine analyzing the filter criteria in the <literal>from</literal>-clause and also in EPL patterns. It is done automatically by the engine.
			</para>

			<para>
				Esper builds and maintains separate sets of filter indexes per event type, when such event type occurs in the <literal>from</literal>-clause or pattern. 
				Filter indexes are sharable within the same event type filter. Thus various <literal>from</literal>-clauses and patterns that refer for the same event type can contribute to the same set of filter indexes.
			</para>
			
			<para>
				Esper builds filter indexes in a nested fashion: Filter indexes may contain further filter indexes, forming a tree-like structure, a filter index tree. The nesting of indexes is beyond the introductory discussion provided here.
			</para>

			<sect2 xml:id="processingmodel_indexes_filterindexes_stmt" revision="1">
				<title>Filter Index Multi-Statement Example</title>

				<para>
					The <literal>from</literal>-clause in a statement and, in special cases, also the <literal>where</literal>-clause provide filter criteria that the engine analyzes and for which it builds filter indexes.
				</para>

				<para>
					For example, assume the <literal>WithdrawalEvent</literal> has an <literal>account</literal> field. You could create three EPL statements like so:
				</para>
				<programlisting><![CDATA[@name('A') select * from WithdrawalEvent(account = 1)]]></programlisting>
				<programlisting><![CDATA[@name('B') select * from WithdrawalEvent(account = 1)]]></programlisting>
				<programlisting><![CDATA[@name('C') select * from WithdrawalEvent(account = 2)]]></programlisting>

				<para>
					In this example, both statement A and statement B register interest in <literal>WithdrawalEvent</literal> events that have an <literal>account</literal> value of 1. 
					Statement C registers interest in <literal>WithdrawalEvent</literal> events that have an <literal>account</literal> value of 2.
				</para>
								
				<para>
					The below table is a sample filter index for the three statements:
				</para>

				<table frame="topbot">
					<title>Sample Filter Index Multi-Statement Example</title>
					<tgroup cols="2">
						<colspec colwidth="0.5*"/>
						<colspec colwidth="1*"/>
						<thead>
							<row>
								<entry>Value of <literal>account</literal></entry>
								<entry>Filter</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>1</literal></entry>
								<entry>Statement A, Statement B</entry>
							</row>
							<row>
								<entry><literal>2</literal></entry>
								<entry>Statement C</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				
				<para>
					When a <literal>Withdrawal</literal> event arrives, the engine extracts the <literal>account</literal> and performs a lookup into above table. 
					If there are no matching rows in the table, for example when the <literal>account</literal> is 3, the engine knows that there is no further processing for the event.
				</para>
			</sect2>
			
			<sect2 xml:id="processingmodel_indexes_filterindexes_pattern" revision="1">
				<title>Filter Index Pattern Example</title>

				<para>
					As part of a pattern you may specify event types and filter criteria. The engine analyzes patterns and determines filter criteria for filter index building. 
				</para>

				<para>
					Consider the following example pattern that fires for each <literal>WithdrawalEvent</literal> that is followed by another <literal>WithdrawalEvent</literal> for the same <literal>account</literal> value:
				</para>
				<programlisting><![CDATA[@name('P') select * from pattern [every w1=WithdrawalEvent -> w2=WithdrawalEvent(account = w.account)]]]></programlisting>

				<para>
					Upon creating the above statement, the engine starts looking for <literal>WithdrawalEvent</literal> events. At this time there is only one active filter:
				</para>
				<itemizedlist>
					<ns:listitem>
						<para>
							 A filter looking for <literal>WithdrawalEvent</literal> events regardless of account id.
						</para>
					</ns:listitem>
				</itemizedlist>

				<para>
					Assume a <literal>WithdrawalEvent</literal> W<subscript>a</subscript> for account 1 arrives. The engine then activates a filter looking for another <literal>WithdrawalEvent</literal> for account 1.
					At this time there are two active filters: 
				</para>
				<itemizedlist>
					<ns:listitem>
						<para>
							 A filter looking for <literal>WithdrawalEvent</literal> events regardless of account id.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>w1</literal>=W<subscript>a</subscript>.
						</para>
					</ns:listitem>
				</itemizedlist>

				<para>
					Assume another <literal>WithdrawalEvent</literal> W<subscript>b</subscript> for account 1 arrives. The engine then activates a filter looking for another <literal>WithdrawalEvent</literal> for account 1.
					At this time there are three active filters: 
				</para>
				<itemizedlist>
					<ns:listitem>
						<para>
							 A filter looking for <literal>WithdrawalEvent</literal> events regardless of account id.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>w1</literal>=W<subscript>a</subscript>.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>w2</literal>=W<subscript>b</subscript>.
						</para>
					</ns:listitem>
				</itemizedlist>

				<para>
					Assume another <literal>WithdrawalEvent</literal> W<subscript>c</subscript> for account 2 arrives. The engine then activates a filter looking for another <literal>WithdrawalEvent</literal> for account 2.
					At this time there are four active filters:
				</para>
				<itemizedlist>
					<ns:listitem>
						<para>
							 A filter looking for <literal>WithdrawalEvent</literal> events regardless of account id.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>w1</literal>=W<subscript>a</subscript>.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>w1</literal>=W<subscript>b</subscript>.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=2)</literal> associated to <literal>w1</literal>=W<subscript>c</subscript>.
						</para>
					</ns:listitem>
				</itemizedlist>

				<para>
					The below table is a sample filter index for the pattern after the W<subscript>a</subscript>, W<subscript>b</subscript>and W<subscript>c</subscript> events arrived:
				</para>

				<table frame="topbot">
					<title>Sample Filter Index Pattern Example</title>
					<tgroup cols="2">
						<colspec colwidth="1*"/>
						<colspec colwidth="1*"/>
						<thead>
							<row>
								<entry>Value of <literal>account</literal></entry>
								<entry>Filter</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>1</literal></entry>
								<entry>Statement P Pattern <literal>w1</literal>=W<subscript>a</subscript>, Statement P Pattern <literal>w1</literal>=W<subscript>b</subscript></entry>
							</row>
							<row>
								<entry><literal>2</literal></entry>
								<entry>Statement P Pattern <literal>w1</literal>=W<subscript>c</subscript></entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<para>
					When a <literal>Withdrawal</literal> event arrives, the engine extracts the <literal>account</literal> and performs a lookup into above table. 
					If a matching row is found, the engine can hand off the event to the relevant pattern subexpressions.
				</para>
			</sect2>
			
			<sect2 xml:id="processingmodel_indexes_filterindexes_context" revision="1">
				<title>Filter Index Context Example</title>

				<para>
					This example is similar to the previous example of multiple statements, but instead it declares a context and associates a single statement to the context.
				</para>

				<para>
					For example, assume the <literal>LoginEvent</literal> has an <literal>account</literal> field. You could declare a context initiated by a <literal>LoginEvent</literal> for a user:
				</para>
				<programlisting><![CDATA[@name('A') create context UserSession initiated by LoginEvent as loginEvent]]></programlisting>

				<para>
					By associating the statement to the context you can tell the engine to analze per <literal>LoginEvent</literal>, for example:
				</para>
				<programlisting><![CDATA[@name('B') context UserSession select count(*) from WithdrawalEvent(account = context.loginEvent.account)]]></programlisting>

				<para>
					Upon creating the above two statements, the engine starts looking for <literal>LoginEvent</literal> events. At this time there is only one active filter:
				</para>
				<itemizedlist>
					<ns:listitem>
						<para>
							 A filter looking for <literal>LoginEvent</literal> events (any account id).
						</para>
					</ns:listitem>
				</itemizedlist>

				<para>
					Assume a <literal>LoginEvent</literal> L<subscript>a</subscript> for account 1 arrives. The engine then activates a context partition of statement B and therefore the filter looking for <literal>WithdrawalEvent</literal> for account 1.
					At this time there are two active filters: 
				</para>
				<itemizedlist>
					<ns:listitem>
						<para>
							 A filter looking for <literal>LoginEvent</literal> events (any account id).
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>loginEvent</literal>=L<subscript>a</subscript>.
						</para>
					</ns:listitem>
				</itemizedlist>
								
				<para>
					Assume a <literal>LoginEvent</literal> L<subscript>b</subscript> for account 1 arrives. The engine then activates a context partition of statement B and therefore the filter looking for <literal>WithdrawalEvent</literal> for account 1.
					At this time there are three active filters: 
				</para>
				<itemizedlist>
					<ns:listitem>
						<para>
							 A filter looking for <literal>LoginEvent</literal> events (any account id).
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>loginEvent</literal>=L<subscript>a</subscript>.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>loginEvent</literal>=L<subscript>b</subscript>.
						</para>
					</ns:listitem>
				</itemizedlist>

				<para>
					Assume a <literal>LoginEvent</literal> L<subscript>c</subscript> for account 2 arrives. The engine then activates a context partition of statement B and therefore the filter looking for <literal>WithdrawalEvent</literal> for account 2.
					At this time there are four active filters: 
				</para>
				<itemizedlist>
					<ns:listitem>
						<para>
							 A filter looking for <literal>LoginEvent</literal> events (any account id).
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>loginEvent</literal>=L<subscript>a</subscript>.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=1)</literal> associated to <literal>loginEvent</literal>=L<subscript>b</subscript>.
						</para>
					</ns:listitem>
					<ns:listitem>
						<para>
							A filter looking for <literal>WithdrawalEvent(account=2)</literal> associated to <literal>loginEvent</literal>=L<subscript>c</subscript>.
						</para>
					</ns:listitem>
				</itemizedlist>

				<para>
					The below table is a sample filter index for the three statement context partitions:
				</para>

				<table frame="topbot">
					<title>Sample Filter Index Context Example</title>
					<tgroup cols="2">
						<colspec colwidth="0.5*"/>
						<colspec colwidth="1*"/>
						<thead>
							<row>
								<entry>Value of <literal>account</literal></entry>
								<entry>Filter</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>1</literal></entry>
								<entry>Statement B Context Partition #0 <literal>loginEvent</literal>=L<subscript>a</subscript>, Statement B Context Partition #1 <literal>loginEvent</literal>=L<subscript>b</subscript></entry>
							</row>
							<row>
								<entry><literal>2</literal></entry>
								<entry>Statement B Context Partition #2 <literal>loginEvent</literal>=L<subscript>c</subscript></entry>
							</row>
						</tbody>
					</tgroup>
				</table>
				
				<para>
					When a <literal>Withdrawal</literal> event arrives, the engine extracts the <literal>account</literal> and performs a lookup into above table. 
					It can then hand of the event directly to the relevant statement context partitions, or ignore the event if no rows are found for a given account id.
				</para>
			</sect2>
		</sect2>
		
		<sect2 xml:id="processingmodel_indexes_eventindexes" revision="1">
			<title>Event Indexes</title>
			
			<para>
				Event indexes organize certain columns so that they can be searched efficiently. Event indexes link back to the row that the column(s) come from.
			</para>

			<para>
			    As event indexes are similar to database indexes, for this discussion, we use the term <emphasis>column</emphasis> to mean a column in a EPL table or named window and to also mean an event property or field.
				We use the term <emphasis>row</emphasis> to mean a row in an EPL table or named window and to also mean an event.
			</para>
			
			<para>
				When the engine performs statement processing it may use event indexes to find correlated rows efficiently.
			</para>

			<para>
				The purpose of event indexes is to enable:
			</para>

			<itemizedlist>
				<ns:listitem>
					<para>Efficient evaluation of subqueries.</para>
				</ns:listitem>
				<ns:listitem>
					<para>Efficient evaluation of joins.</para>
				</ns:listitem>
				<ns:listitem>
					<para>Efficient evaluation of on-action statements.</para>
				</ns:listitem>
				<ns:listitem>
					<para>Efficient evaluation of fire-and-forget queries.</para>
				</ns:listitem>
			</itemizedlist>

			<para>
				Event index building is a result of the engine analyzing the <literal>where-</literal>clause correlation criteria for joins (<literal>on-</literal>clause for outer joins), subqueries, on-action and fire-and-forget queries.
				It is done automatically by the engine. You may utilize the <literal>create index</literal> clause to explicitly index named windows and tables. You may utilize query planner hints to influence index building, use and sharing.
			</para>
		</sect2>		
	</sect1>

    <sect1 xml:id="processingmodel_3valuedlogic" revision="1">
        <title>Basic Null</title>
        
        <para>
			EPL and SQL use a three-valued logic: besides <literal>true</literal> and <literal>false</literal>, the result of expressions can also be unknown. Three-valued logic is a consequence of supporting <literal>null</literal> to mark absent data. 
			If a <literal>null</literal> value affects the result of a logical expression, the result is neither <literal>true</literal> nor <literal>false</literal> but unknown.
        </para>
        
        <para>
			A <literal>null</literal> value basically means “could be anything”. It is therefore impossible to tell whether a comparison to <literal>null</literal> is <literal>true</literal> or <literal>false</literal>. 
			That’s where the third logical value, unknown, comes in. Unknown means “true or false, depending on the null values”.
        </para>

		<para>
			The result of each of the following comparisons is therefore <literal>null</literal> (unknown):
		</para>
		<programlisting>null = 1</programlisting>
		<programlisting>null &lt;&gt; 1</programlisting>
		<programlisting>null &gt; 1</programlisting>
		<programlisting>null = null</programlisting>

		<para>
			Nothing <emphasis>equals</emphasis> null. Not even <literal>null</literal> equals <literal>null</literal> because each <literal>null</literal> could be different. 
			That’s why EPL has the <literal>is null</literal> predicate to test whether a value is null or not.
		</para>
		<para>
			Credit: Above is an excerpt from an online text that can be found at <link xlink:href="http://modern-sql.com/concept/three-valued-logic">http://modern-sql.com/concept/three-valued-logic</link>.
		</para>
	</sect1>
		
</chapter>
