<?xml version="1.0" encoding="UTF-8"?><!--     Sample configuration file.    This is a sample configuration file. It presents most or all configuration options in XML.        The configuration herein is not the default configuration. Please remove all elements for the default configuration, and add elements as needed for your required settings.    An empty XML configuration file (empty except for the esper-configuration root element) represents the default configuration and is equivalent to the API call of "new Configuration()".    We recommend starting with the default "esper.default.cfg" configuration file instead for new projects.--><esper-configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns="http://www.espertech.com/schema/esper"    xsi:noNamespaceSchemaLocation="esper-configuration-5-0.xsd"><!--     Alternatively use the following external schema:   xsi:schemaLocation="http://www.espertech.com/schema/esper http://www.espertech.com/schema/esper/esper-configuration-5-0.xsd"> -->     <!-- Adds a Java package name of a package that Java event classes reside in. This setting allows an application to place all it's events into one or more Java packages            and then declare these packages. The engine attempts to resolve an event type name to a Java class residing in each declared package. -->	<event-type-auto-name package-name="com.mycompany.eventsone"/>	<!-- Event type names for plain Java-object events.  -->		<event-type name="MyJavaBeanEvent" class="com.mycompany.myapp.MySampleEvent"/>	<!-- Event type names for java.util.Map events. In this example the map type has supertypes (optional) that are not part of this example.-->	<event-type name="MyMapEvent">		<java-util-map supertype-names="MyMapSuperType1, MyMapSuperType2">			<map-property name="carId" class="int"/>			<map-property name="carName" class="string"/>			<map-property name="assembly" class="com.mycompany.Assembly"/>		</java-util-map>	</event-type>		<!-- Event type names for XML document object model DOM events of type org.w3c.dom.Node-->		<event-type name="MyXMLNodeEvent">			<!-- This example specifies a schema resolved from classpath. It specifies that property expression are backed by DOM-access, and that EventSender instances check the root element name.-->		<xml-dom root-element-name="rootelement" schema-resource="optional.xsd" default-namespace="urn:specification:xml:myschema:1" xpath-property-expr="false" event-sender-validates-root="true">			<namespace-prefix prefix="myprefix" namespace="urn:specification:xml:myschema:1"/>			<!-- XPath expressions type is the QName type that returns string, number, or boolean. -->			<xpath-property property-name="mycount" xpath="count(/myprefix:elementone/myprefix:elementtwo)" type="number"/>			<!-- XPath expressions return values can also be casted; this property will be treated as a XPath expression returning a string that is parsed and returns a long-value. -->			<xpath-property property-name="price" xpath="/tick/spot/price" type="string" cast="long"/>			<!-- XPath expressions may also return  values that are themselves an event fragment.-->			<xpath-property property-name="price" xpath="/bookstore/book" type="nodeset" event-type-name="MyOtherXMLNodeEvent"/>		</xml-dom>	</event-type>		<!-- Event type names for a legacy Java class-->	<!-- A factory method is optional and used when the object can not be instantiated directly, for use with insert-into. May either specify just a method name or a class and method name.-->		<event-type name="MyLegacyTypeEvent" class="com.mycompany.package.MyLegacyTypeEvent">		<legacy-type accessor-style="public" code-generation="enabled" property-resolution-style="case_insensitive" factory-method="com.mycompany.package.MySampleEventFactory.createMyLegacyTypeEvent">			<method-property name="mymethodprop" accessor-method="myAccessorMethod" />			<field-property name="myfieldprop" accessor-field="myFieldName" />		</legacy-type>	</event-type>    <!-- Sample for an event type configuration that handles event updates (aka. versions, revisions). -->	<revision-event-type name="MyRevisionEvent">	  <base-event-type name="MyBaseEventName"/>	  <delta-event-type name="MyDeltaEventNameOne"/>	  <delta-event-type name="MyDeltaEventNameTwo"/>	  <key-property name="id"/>	</revision-event-type>	    <!-- Sample for an variant stream configuration that is a stream of events of multiple types. -->	<variant-stream name="MyVariantStream">	  <variant-event-type name="MyFirstEvent"/>		  <variant-event-type name="MySecondEvent"/>		</variant-stream>		<!-- Import Packages and Classes -->	<auto-import import-name="com.mycompany.mypackage.*"/>	<auto-import import-name="com.mycompany.myapp.MyUtilityClass"/>    <!-- Configure caches for from-clause method invocations -->	    <method-reference class-name="com.mycompany.MyFromClauseLookupLib">		<expiry-time-cache max-age-seconds="10" purge-interval-seconds="10" ref-type="weak"/> <!-- Configures an time-based cache with a maximum age in seconds and a purge interval, and an optional reference strategy  -->			    </method-reference> 	    <method-reference class-name="com.mycompany.MyFromClauseWebServiceLib">		<lru-cache size="1000"/> <!-- Configures an LRU cache with a size of 1000 -->    </method-reference> 	<!-- Sample configuration for database access using InitialContext and DataSource -->	<database-reference name="mydb1">		<datasource-connection context-lookup-name="java:comp/env/jdbc/mydb">			<env-property name="java.naming.factory.initial" value ="com.myclass.CtxFactory"/>			<env-property name="java.naming.provider.url" value ="iiop://localhost:1050"/>		</datasource-connection>		<connection-settings auto-commit="true" catalog="somecatalog" read-only="true" transaction-isolation="1" />	<!-- Optional settings on connections -->		<connection-lifecycle value="pooled"/>		<!-- Obtains a new connection and closes the connection on every use, for connection pooling -->		<lru-cache size="10"/>				<!-- Configures an optional LRU cache with a size of 10 -->		<column-change-case value="lowercase"/>  <!-- used to indicate to convert all columns to lowercase -->		<metadata-origin value="sample" />	<!-- for database drivers (Oracle) that don't support prepared stmt metadata, derive from a sample statement, see doc -->		<sql-types-mapping sql-type="2" java-type="int" />  <!-- map SQL type to Java type, see java.sql.Types for valid values -->		<sql-types-mapping sql-type="6" java-type="float" />	</database-reference>		<!-- Sample configuration for database access using DriverManager; retains connections associated with a statement, closing the connection when a statement is stopped -->	<database-reference name="mydb2">		<drivermanager-connection class-name="my.sql.Driver" url="jdbc:mysql://localhost/test?user=root&amp;password=welcome" user="myuser" password="mypassword">			<connection-arg name="user" value ="myuser"/>			<connection-arg name="password" value ="mypassword"/>			<connection-arg name="somearg" value ="someargvalue"/>		</drivermanager-connection>		<connection-lifecycle value="retain"/>		<!-- Retains connection associated with a statement, closing a connection only when a statement is stopped -->		<expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" ref-type="weak"/>	<!-- Configures an optional time-based cache with a maximum age in seconds and a purge interval, and an optional reference strategy  -->				</database-reference>	<!-- Sample configuration for database access using Apache DBCP; passes properties to the DBCP-provided connection pool that pools connections; Getting a connection from pool and returning (closing) the connection when a query is done. -->	<database-reference name="mydb3">		<datasourcefactory-connection class-name="org.apache.commons.dbcp.BasicDataSourceFactory">	<!-- For a complete list of properties see Apache DBCP. -->			<env-property name="username" value ="myusername"/>			<env-property name="password" value ="mypassword"/>			<env-property name="driverClassName" value ="com.mysql.jdbc.Driver"/>			<env-property name="url" value ="jdbc:mysql://localhost/test"/>			<env-property name="initialSize" value ="2"/>		</datasourcefactory-connection>		<connection-lifecycle value="pooled"/>	</database-reference>	<!-- Sample configuration for plugging-in a custom view implementation -->	<plugin-view namespace="ext" name="myview" factory-class="com.espertech.esper.regression.client.MyTrendSpotterViewFactory" />	<!-- Sample configuration for plugging-in a virtual data window implementation -->	<plugin-view namespace="vdw" name="myvirtual" factory-class="com.espertech.esper.regression.client.MyVirtualDataWindowFactory" />	<!-- Sample configuration for plug-in a custom aggregation function -->	<plugin-aggregation-function name="concat" factory-class="com.espertech.esper.regression.client.MyConcatAggregationFunctionFactory" />	<!-- Sample configuration for plug-in a custom single-row function -->	<plugin-singlerow-function name="powerOf" function-class="com.espertech.esper.regression.client.MySingleRowFunction" function-method="computePowerOf" />	<!-- Sample configuration for plugging-in a custom pattern guard -->	<plugin-pattern-guard namespace="myspace" name="count" factory-class="com.espertech.esper.regression.client.MyCountToPatternGuardFactory"/>	<!-- Sample configuration for plugging-in a custom pattern observer -->	<plugin-pattern-observer namespace="myspace" name="file_exists" factory-class="com.espertech.esper.regression.client.MyFileExistsObserverFactory" />	<!-- Sample configuration for plugging-in a new event representation -->	<plugin-event-representation uri="type://formatName/sampleRepresentation/sampleName" class-name="com.espertech.esper.regression.event.MyPlugInEventRepresentation">	  <initializer>	    <anyxml>This is sample content passed to the event representation as a configuration string, if present (optional element)</anyxml>	  </initializer>	</plugin-event-representation>		<!-- Sample configuration for plugging-in a new event type -->	<plugin-event-type name="MyEvent">	  <resolution-uri value="type://formatName/sampleRepresentation"/>	  <resolution-uri value="type://formatName/sampleSecondRepresentation"/>	  <initializer>	    <anyxml>This is sample content passed to the event representation resolving the event type as a configuration string for the specific event type, if present (optional element)</anyxml>	  </initializer>	</plugin-event-type>	<!-- Sample configuration for specifying how to resolve new (unseen) event type names in EPL statements -->	<plugin-event-type-name-resolution>	  <resolution-uri value="type://formatName/sampleRepresentation"/>	  <resolution-uri value="type://formatName/sampleSecondRepresentation"/>	</plugin-event-type-name-resolution>	<!-- Sample variable, first an integer initialized to 1, then a string initialized to null -->	<variable name="varMyCounter" type="int" initialization-value="1"/>	<variable name="varMyProductName" type="string"/>	<!-- Sample configuration for an input/output adapter loader -->	<plugin-loader name="MyLoader" class-name="com.espertech.esperio.SpringContextLoader">			<!-- SpringApplicationContext translates into Spring ClassPathXmlApplicationContext or FileSystemXmlApplicationContext -->			<!-- Only one app-context of a sort can be used. When both attributes are used classpath and file, classpath prevails -->		<init-arg name="classpath-app-context" value="spring\jms-spring.xml" />		<init-arg name="file-app-context" value="spring\jms-spring.xml" />		<config-xml>	<!-- Contains xml:any and may therefore contain any configuration XML desirable for the plugin. -->			<sample-initializer><some-any-xml-can-be-here>This section for use by a plugin loader.</some-any-xml-can-be-here></sample-initializer>		</config-xml>	</plugin-loader>			<!-- Sample engine settings -->	<engine-settings>		<defaults>			<threading>				<!-- In multithreaded environments, this setting controls whether dispatches to listeners preserve the ordering in which the statement processes events -->				<listener-dispatch preserve-order="true" timeout-msec="1000" locking="spin"/>				<!-- In multithreaded environments, this setting controls whether insert-into streams preserve the order of events inserted into them by one or more statements, -->				<!-- allowing statements that consume other statement's events to behave deterministic -->				<insert-into-dispatch preserve-order="true" timeout-msec="100" locking="spin"/>				<!-- These settings define the resolution of the internal timer thread, and can disable the timer  to indicate that the application supplies the timer events -->				<internal-timer enabled="true" msec-resolution="100"/>				<!-- Configure inbound threading, false by default. The optional capacity attribute instructs a capacity-bound queue and sender-wait policy. Without capacity the queue is unbounded. -->				<threadpool-inbound enabled="false" num-threads="0" capacity="1000"/>				<!-- Configure outbound threading, false by default. -->				<threadpool-outbound enabled="false" num-threads="0"/>				<!-- Configure timer execution threading, false by default. -->				<threadpool-timerexec enabled="false" num-threads="0"/>				<!-- Configure route execution threading, false by default. -->				<threadpool-routeexec enabled="false" num-threads="0"/>			</threading>			<event-meta>			    <!-- Lets configure the engine to use case-insensitive resolution for event properties -->				<class-property-resolution style="distinct_case_insensitive"/>			</event-meta>			<view-resources>			    <!-- Lets configure the engine to reuse views, which is the default but can introduce additional locking. -->				<share-views enabled="true"/>			    <!-- This setting is false by default. When false, multiple expiry policies (EPL statements where a stream has multiple data windows) are allowed and result in an expiry policy that retains the intersection of the data windows. See retain-intersection and retain-union keywords.					   When setting this flag to true, and when multiple expiry policies are specified for a stream, the data windows act by forwarding the insert and remove stream and thus intersecion and union behavior is not available. 					   The setting is available for backward-compatilibility to 2.x versions or special cases where custom behavior is desired.				-->				<allow-multiple-expiry-policy enabled="false"/>			</view-resources>			<logging>			    <!-- By default the engine does not generate logging through Log4j of the event processing execution path. To get debug output, set this flag to true. --> 			    <!-- This setting translates into a static boolean flag and thus may apply to multiple engine instances within a given VM. -->				<execution-path enabled="false" />			    <!-- By default the engine generates timer debug level logging through Log4j (true by default). To remove all timer-related debug-level output, set this flag to false. --> 			    <!-- This setting translates into a static boolean flag and thus may apply to multiple engine instances within a given VM. -->				<timer-debug enabled="false" />			    <!-- By default the engine does not report JBDC query performance information or other relevant JDBC API information. By setting this flag JDBC query information is measured and logged at information level.-->				<jdbc enabled="false" />			    <!-- By default the engine does not report query plan information unless logging at debug level. By setting this flag query plan information is logged at information level..-->				<query-plan enabled="false"/>			</logging>			<stream-selection>			    <!-- By default the engine generates output for the insert stream only, and not for the remove stream. The "istream" is the default. --> 			    <!-- To obtain output for remove stream only, or for insert stream and remove stream, there are keywords "rstream" and "irstream" for use in the select clause. -->			    <!-- This setting controls the default behavior, if no keyword is specified in the select-clause by statements. -->				<stream-selector value="istream" />			</stream-selection>			<time-source>			    <!-- By default the time source is System.currentTimeMillis; This sample configures the nano-second time call System.nanoTime() as the time source, which Esper adjusts for wall clock time.  --> 				<time-source-type value="nano" />			</time-source>			<!-- By default metrics reporting is disabled. Enable by setting the below. -->			<metrics-reporting enabled="false" engine-interval="1000" statement-interval="1000" threading="true">				<stmtgroup name="MyStmtGroup" interval="1000" default-include="true" num-stmts="100" report-inactive="true">				    <!-- samples of include/exclude using RegEx and SQL-Like syntax -->					<include-like>%MyFraudAnalysisStatement%</include-like>					<exclude-like>%MyMetricsStatement%</exclude-like>					<include-regex>.*</include-regex>					<exclude-regex>.*test.*</exclude-regex>				</stmtgroup>			</metrics-reporting>			<!-- Set string-value sorts to use Collator by setting this flag to true. -->			<language sort-using-collator="false"/>					<!-- 				Set division between integer values to return integer instead of double by setting this flag to true (default is false). 				Set division by zero to return null and not Double.infinity (default is false). 				Turn on caching of UDF function results for constant parameters (default is on).				Set evaluation of sub-selects that react to the same event to evaluate first within the same statement (default is true, i.e. subselects evaluate first).				Set duck-typing off: by default method invocations are validated strongly typed. Set to true to enable duck-typing.			--> 			<expression integer-division="false" division-by-zero-is-null="false" udf-cache="true" self-subselect-preeval="true" extended-agg="true" ducktyping="false"/>			<!-- By default prioritized statement execution is disabled. Enable by setting the flag. -->			<execution prioritized="false"/>			<!-- Register exception handler instances that receive all engine exceptions other then listener and method invocation exceptions. -->			<exceptionHandling>				<handlerFactory class="my.company.cep.LoggingExceptionHandlerFactory"/>				<handlerFactory class="my.company.cep.AlertExceptionHandlerFactory"/>			</exceptionHandling>			<!-- Register condition handler instances that receive notification when certain statement-level conditions occur such as when a maximum pattern sub-expression instance count is reached. -->			<conditionHandling>				<handlerFactory class="my.company.cep.LoggingConditionHandlerFactory"/>				<handlerFactory class="my.company.cep.AlertConditionHandlerFactory"/>			</conditionHandling>		</defaults>	</engine-settings></esper-configuration>